{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-filter",
  "type": "registry:block",
  "title": "Data table filter",
  "author": "Kian Bazarjani <kian@bazza.dev>",
  "description": "A powerful data table filter component inspired by Linear.",
  "dependencies": ["@bazzaui/filters@canary", "date-fns"],
  "registryDependencies": [
    "button",
    "calendar",
    "checkbox",
    "command",
    "dropdown-menu",
    "input",
    "label",
    "popover",
    "separator",
    "slider",
    "table",
    "tabs",
    "use-mobile"
  ],
  "files": [
    {
      "path": "registry/data-table-filter/index.tsx",
      "content": "export { DataTableFilter } from './components/data-table-filter'\n",
      "type": "registry:file",
      "target": "components/data-table-filter/index.tsx"
    },
    {
      "path": "registry/data-table-filter/components/active-filters.tsx",
      "content": "import type {\n  Column,\n  ColumnDataType,\n  DataTableFilterActions,\n  FilterModel,\n  FilterStrategy,\n  FiltersState,\n  Locale,\n} from '@bazzaui/filters'\nimport { getColumn } from '@bazzaui/filters'\nimport { X } from 'lucide-react'\nimport { useEffect, useRef, useState } from 'react'\nimport { Button } from '@/components/ui/button'\nimport { Separator } from '@/components/ui/separator'\nimport { FilterOperator } from './filter-operator'\nimport { FilterSubject } from './filter-subject'\nimport { FilterValue } from './filter-value'\n\ninterface ActiveFiltersProps<TData> {\n  columns: Column<TData>[]\n  filters: FiltersState\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n  locale?: Locale\n}\n\nexport function ActiveFilters<TData>({\n  columns,\n  filters,\n  actions,\n  strategy,\n  locale = 'en',\n}: ActiveFiltersProps<TData>) {\n  return (\n    <>\n      {filters.map((filter) => {\n        const id = filter.columnId\n\n        const column = getColumn(columns, id)\n\n        // Skip if no filter value\n        if (!filter.values) return null\n\n        return (\n          <ActiveFilter\n            key={`active-filter-${filter.columnId}`}\n            filter={filter}\n            column={column}\n            actions={actions}\n            strategy={strategy}\n            locale={locale}\n          />\n        )\n      })}\n    </>\n  )\n}\n\ninterface ActiveFilterProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n  locale?: Locale\n}\n\n// Generic render function for a filter with type-safe value\nexport function ActiveFilter<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n  strategy,\n  locale = 'en',\n}: ActiveFilterProps<TData, TType>) {\n  return (\n    <div className=\"flex h-7 items-center rounded-2xl border border-border bg-background shadow-xs text-xs\">\n      <FilterSubject column={column} />\n      <Separator orientation=\"vertical\" />\n      <FilterOperator\n        filter={filter}\n        column={column}\n        actions={actions}\n        locale={locale}\n      />\n      <Separator orientation=\"vertical\" />\n      <FilterValue\n        filter={filter}\n        column={column}\n        actions={actions}\n        strategy={strategy}\n        locale={locale}\n      />\n      <Separator orientation=\"vertical\" />\n      <Button\n        variant=\"ghost\"\n        className=\"rounded-none rounded-r-2xl text-xs w-7 h-full\"\n        onClick={() => actions.removeFilter(filter.columnId)}\n      >\n        <X className=\"size-4 -translate-x-0.5\" />\n      </Button>\n    </div>\n  )\n}\n\nexport function ActiveFiltersMobileContainer({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const scrollContainerRef = useRef<HTMLDivElement>(null)\n  const [showLeftBlur, setShowLeftBlur] = useState(false)\n  const [showRightBlur, setShowRightBlur] = useState(true)\n\n  // Check if there's content to scroll and update blur states\n  const checkScroll = () => {\n    if (scrollContainerRef.current) {\n      const { scrollLeft, scrollWidth, clientWidth } =\n        scrollContainerRef.current\n\n      // Show left blur if scrolled to the right\n      setShowLeftBlur(scrollLeft > 0)\n\n      // Show right blur if there's more content to scroll to the right\n      // Add a small buffer (1px) to account for rounding errors\n      setShowRightBlur(scrollLeft + clientWidth < scrollWidth - 1)\n    }\n  }\n\n  // Log blur states for debugging\n  // useEffect(() => {\n  //   console.log('left:', showLeftBlur, '  right:', showRightBlur)\n  // }, [showLeftBlur, showRightBlur])\n\n  // Set up ResizeObserver to monitor container size\n  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n  useEffect(() => {\n    if (scrollContainerRef.current) {\n      const resizeObserver = new ResizeObserver(() => {\n        checkScroll()\n      })\n      resizeObserver.observe(scrollContainerRef.current)\n      return () => {\n        resizeObserver.disconnect()\n      }\n    }\n  }, [])\n\n  // Update blur states when children change\n  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n  useEffect(() => {\n    checkScroll()\n  }, [children])\n\n  return (\n    <div className=\"relative w-full overflow-x-hidden\">\n      {/* Left blur effect */}\n      {showLeftBlur && (\n        <div className=\"absolute left-0 top-0 bottom-0 w-16 z-10 pointer-events-none bg-gradient-to-r from-background to-transparent animate-in fade-in-0\" />\n      )}\n\n      {/* Scrollable container */}\n      <div\n        ref={scrollContainerRef}\n        className=\"flex gap-2 overflow-x-scroll no-scrollbar\"\n        onScroll={checkScroll}\n      >\n        {children}\n      </div>\n\n      {/* Right blur effect */}\n      {showRightBlur && (\n        <div className=\"absolute right-0 top-0 bottom-0 w-16 z-10 pointer-events-none bg-gradient-to-l from-background to-transparent animate-in fade-in-0 \" />\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/components/active-filters.tsx"
    },
    {
      "path": "registry/data-table-filter/components/data-table-filter.tsx",
      "content": "'use client'\n\nimport type {\n  Column,\n  DataTableFilterActions,\n  FilterStrategy,\n  FiltersState,\n  Locale,\n} from '@bazzaui/filters'\nimport { useIsMobile } from '@/hooks/use-mobile'\nimport { ActiveFilters, ActiveFiltersMobileContainer } from './active-filters'\nimport { FilterActions } from './filter-actions'\nimport { FilterSelector } from './filter-selector'\n\ninterface DataTableFilterProps<TData> {\n  columns: Column<TData>[]\n  filters: FiltersState\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n  locale?: Locale\n}\n\nexport function DataTableFilter<TData>({\n  columns,\n  filters,\n  actions,\n  strategy,\n  locale = 'en',\n}: DataTableFilterProps<TData>) {\n  const isMobile = useIsMobile()\n  if (isMobile) {\n    return (\n      <div className=\"flex w-full items-start justify-between gap-2\">\n        <div className=\"flex gap-1\">\n          <FilterSelector\n            columns={columns}\n            filters={filters}\n            actions={actions}\n            strategy={strategy}\n            locale={locale}\n          />\n          <FilterActions\n            hasFilters={filters.length > 0}\n            actions={actions}\n            locale={locale}\n          />\n        </div>\n        <ActiveFiltersMobileContainer>\n          <ActiveFilters\n            columns={columns}\n            filters={filters}\n            actions={actions}\n            strategy={strategy}\n            locale={locale}\n          />\n        </ActiveFiltersMobileContainer>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex w-full items-start justify-between gap-2\">\n      <div className=\"flex md:flex-wrap gap-2 w-full flex-1\">\n        <FilterSelector\n          columns={columns}\n          filters={filters}\n          actions={actions}\n          strategy={strategy}\n          locale={locale}\n        />\n        <ActiveFilters\n          columns={columns}\n          filters={filters}\n          actions={actions}\n          strategy={strategy}\n          locale={locale}\n        />\n      </div>\n      <FilterActions\n        hasFilters={filters.length > 0}\n        actions={actions}\n        locale={locale}\n      />\n    </div>\n  )\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/components/data-table-filter.tsx"
    },
    {
      "path": "registry/data-table-filter/components/filter-actions.tsx",
      "content": "import { type DataTableFilterActions, type Locale, t } from '@bazzaui/filters'\nimport { FilterXIcon } from 'lucide-react'\nimport { memo } from 'react'\nimport { Button } from '@/components/ui/button'\nimport { cn } from '@/lib/utils'\n\ninterface FilterActionsProps {\n  hasFilters: boolean\n  actions?: DataTableFilterActions\n  locale?: Locale\n}\n\nexport const FilterActions = memo(__FilterActions)\nfunction __FilterActions({\n  hasFilters,\n  actions,\n  locale = 'en',\n}: FilterActionsProps) {\n  return (\n    <Button\n      className={cn('h-7 !px-2', !hasFilters && 'hidden')}\n      variant=\"destructive\"\n      onClick={actions?.removeAllFilters}\n    >\n      <FilterXIcon />\n      <span className=\"hidden md:block\">{t('clear', locale)}</span>\n    </Button>\n  )\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-actions.tsx"
    },
    {
      "path": "registry/data-table-filter/components/filter-operator.tsx",
      "content": "import {\n  type Column,\n  type ColumnDataType,\n  type DataTableFilterActions,\n  dateFilterOperators,\n  type FilterModel,\n  type FilterOperators,\n  filterTypeOperatorDetails,\n  type Locale,\n  multiOptionFilterOperators,\n  numberFilterOperators,\n  optionFilterOperators,\n  t,\n  textFilterOperators,\n} from '@bazzaui/filters'\nimport { useState } from 'react'\nimport { Button } from '@/components/ui/button'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\n\ninterface FilterOperatorProps<TData, TType extends ColumnDataType> {\n  column: Column<TData, TType>\n  filter: FilterModel<TType>\n  actions: DataTableFilterActions\n  locale?: Locale\n}\n\n// Renders the filter operator display and menu for a given column filter\n// The filter operator display is the label and icon for the filter operator\n// The filter operator menu is the dropdown menu for the filter operator\nexport function FilterOperator<TData, TType extends ColumnDataType>({\n  column,\n  filter,\n  actions,\n  locale = 'en',\n}: FilterOperatorProps<TData, TType>) {\n  const [open, setOpen] = useState<boolean>(false)\n\n  const close = () => setOpen(false)\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"ghost\"\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\n        >\n          <FilterOperatorDisplay\n            filter={filter}\n            columnType={column.type}\n            locale={locale}\n          />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        align=\"start\"\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\n      >\n        <Command loop>\n          <CommandInput placeholder={t('search', locale)} />\n          <CommandEmpty>{t('noresults', locale)}</CommandEmpty>\n          <CommandList className=\"max-h-fit\">\n            <FilterOperatorController\n              filter={filter}\n              column={column}\n              actions={actions}\n              closeController={close}\n              locale={locale}\n            />\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n\ninterface FilterOperatorDisplayProps<TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  columnType: TType\n  locale?: Locale\n}\n\nexport function FilterOperatorDisplay<TType extends ColumnDataType>({\n  filter,\n  columnType,\n  locale = 'en',\n}: FilterOperatorDisplayProps<TType>) {\n  const operator = filterTypeOperatorDetails[columnType][filter.operator]\n  const label = t(operator.key, locale)\n\n  return <span className=\"text-muted-foreground\">{label}</span>\n}\n\ninterface FilterOperatorControllerProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n  closeController: () => void\n  locale?: Locale\n}\n\n/*\n *\n * TODO: Reduce into a single component. Each data type does not need it's own controller.\n *\n */\nexport function FilterOperatorController<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n  closeController,\n  locale = 'en',\n}: FilterOperatorControllerProps<TData, TType>) {\n  switch (column.type) {\n    case 'option':\n      return (\n        <FilterOperatorOptionController\n          filter={filter as FilterModel<'option'>}\n          column={column as Column<TData, 'option'>}\n          actions={actions}\n          closeController={closeController}\n          locale={locale}\n        />\n      )\n    case 'multiOption':\n      return (\n        <FilterOperatorMultiOptionController\n          filter={filter as FilterModel<'multiOption'>}\n          column={column as Column<TData, 'multiOption'>}\n          actions={actions}\n          closeController={closeController}\n          locale={locale}\n        />\n      )\n    case 'date':\n      return (\n        <FilterOperatorDateController\n          filter={filter as FilterModel<'date'>}\n          column={column as Column<TData, 'date'>}\n          actions={actions}\n          closeController={closeController}\n          locale={locale}\n        />\n      )\n    case 'text':\n      return (\n        <FilterOperatorTextController\n          filter={filter as FilterModel<'text'>}\n          column={column as Column<TData, 'text'>}\n          actions={actions}\n          closeController={closeController}\n          locale={locale}\n        />\n      )\n    case 'number':\n      return (\n        <FilterOperatorNumberController\n          filter={filter as FilterModel<'number'>}\n          column={column as Column<TData, 'number'>}\n          actions={actions}\n          closeController={closeController}\n          locale={locale}\n        />\n      )\n    default:\n      return null\n  }\n}\n\nfunction FilterOperatorOptionController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n  locale = 'en',\n}: FilterOperatorControllerProps<TData, 'option'>) {\n  const filterDetails = optionFilterOperators[filter.operator]\n\n  const relatedFilters = Object.values(optionFilterOperators).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(column.id, value as FilterOperators['option'])\n    closeController()\n  }\n\n  return (\n    <CommandGroup heading={t('operators', locale)}>\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {t(r.key, locale)}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nfunction FilterOperatorMultiOptionController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n  locale = 'en',\n}: FilterOperatorControllerProps<TData, 'multiOption'>) {\n  const filterDetails = multiOptionFilterOperators[filter.operator]\n\n  const relatedFilters = Object.values(multiOptionFilterOperators).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(\n      column.id,\n      value as FilterOperators['multiOption'],\n    )\n    closeController()\n  }\n\n  return (\n    <CommandGroup heading={t('operators', locale)}>\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {t(r.key, locale)}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nfunction FilterOperatorDateController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n  locale = 'en',\n}: FilterOperatorControllerProps<TData, 'date'>) {\n  const filterDetails = dateFilterOperators[filter.operator]\n\n  const relatedFilters = Object.values(dateFilterOperators).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(column.id, value as FilterOperators['date'])\n    closeController()\n  }\n\n  return (\n    <CommandGroup>\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {t(r.key, locale)}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nexport function FilterOperatorTextController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n  locale = 'en',\n}: FilterOperatorControllerProps<TData, 'text'>) {\n  const filterDetails = textFilterOperators[filter.operator]\n\n  const relatedFilters = Object.values(textFilterOperators).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(column.id, value as FilterOperators['text'])\n    closeController()\n  }\n\n  return (\n    <CommandGroup heading={t('operators', locale)}>\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {t(r.key, locale)}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nfunction FilterOperatorNumberController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n  locale = 'en',\n}: FilterOperatorControllerProps<TData, 'number'>) {\n  const filterDetails = numberFilterOperators[filter.operator]\n\n  const relatedFilters = Object.values(numberFilterOperators).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(column.id, value as FilterOperators['number'])\n    closeController()\n  }\n\n  return (\n    <div>\n      <CommandGroup heading={t('operators', locale)}>\n        {relatedFilters.map((r) => (\n          <CommandItem\n            onSelect={() => changeOperator(r.value)}\n            value={r.value}\n            key={r.value}\n          >\n            {t(r.key, locale)}\n          </CommandItem>\n        ))}\n      </CommandGroup>\n    </div>\n  )\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-operator.tsx"
    },
    {
      "path": "registry/data-table-filter/components/filter-selector.tsx",
      "content": "import {\n  type Column,\n  type ColumnDataType,\n  type DataTableFilterActions,\n  type FilterStrategy,\n  type FiltersState,\n  getColumn,\n  isAnyOf,\n  type Locale,\n  t,\n} from '@bazzaui/filters'\nimport { ArrowRightIcon, ChevronRightIcon, FilterIcon } from 'lucide-react'\nimport React, {\n  isValidElement,\n  memo,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport { Button } from '@/components/ui/button'\nimport { Checkbox } from '@/components/ui/checkbox'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\nimport { cn } from '@/lib/utils'\nimport { FilterValueController } from './filter-value'\n\ninterface FilterSelectorProps<TData> {\n  filters: FiltersState\n  columns: Column<TData>[]\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n  locale?: Locale\n}\n\nexport const FilterSelector = memo(__FilterSelector) as typeof __FilterSelector\n\nfunction __FilterSelector<TData>({\n  filters,\n  columns,\n  actions,\n  strategy,\n  locale = 'en',\n}: FilterSelectorProps<TData>) {\n  const [open, setOpen] = useState(false)\n  const [value, setValue] = useState('')\n  const [property, setProperty] = useState<string | undefined>(undefined)\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  const column = property ? getColumn(columns, property) : undefined\n  const filter = property\n    ? filters.find((f) => f.columnId === property)\n    : undefined\n\n  const hasFilters = filters.length > 0\n\n  useEffect(() => {\n    if (property && inputRef) {\n      inputRef.current?.focus()\n      setValue('')\n    }\n  }, [property])\n\n  useEffect(() => {\n    if (!open) setTimeout(() => setValue(''), 150)\n  }, [open])\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: need filters to be updated\n  const content = useMemo(\n    () =>\n      property && column ? (\n        <FilterValueController\n          filter={filter!}\n          column={column as Column<TData, ColumnDataType>}\n          actions={actions}\n          strategy={strategy}\n          locale={locale}\n        />\n      ) : (\n        <Command\n          loop\n          filter={(value, search, keywords) => {\n            const extendValue = `${value} ${keywords?.join(' ')}`\n            return extendValue.toLowerCase().includes(search.toLowerCase())\n              ? 1\n              : 0\n          }}\n        >\n          <CommandInput\n            value={value}\n            onValueChange={setValue}\n            ref={inputRef}\n            placeholder={t('search', locale)}\n          />\n          <CommandEmpty>{t('noresults', locale)}</CommandEmpty>\n          <CommandList className=\"max-h-fit\">\n            <CommandGroup>\n              {columns.map((column) => (\n                <FilterableColumn\n                  key={column.id}\n                  column={column}\n                  setProperty={setProperty}\n                />\n              ))}\n              <QuickSearchFilters\n                search={value}\n                filters={filters}\n                columns={columns}\n                actions={actions}\n                strategy={strategy}\n                locale={locale}\n              />\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      ),\n    [property, column, filter, filters, columns, actions, value],\n  )\n\n  return (\n    <Popover\n      open={open}\n      onOpenChange={async (value) => {\n        setOpen(value)\n        if (!value) setTimeout(() => setProperty(undefined), 100)\n      }}\n    >\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"outline\"\n          className={cn('h-7', hasFilters && 'w-fit !px-2')}\n        >\n          <FilterIcon className=\"size-4\" />\n          {!hasFilters && <span>{t('filter', locale)}</span>}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        align=\"start\"\n        side=\"bottom\"\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\n      >\n        {content}\n      </PopoverContent>\n    </Popover>\n  )\n}\n\nexport function FilterableColumn<TData, TType extends ColumnDataType, TVal>({\n  column,\n  setProperty,\n}: {\n  column: Column<TData, TType, TVal>\n  setProperty: (value: string) => void\n}) {\n  const itemRef = useRef<HTMLDivElement>(null)\n\n  const { icon: Icon } = column\n  const hasIcon = !!Icon\n\n  const prefetch = useCallback(() => {\n    column.prefetchValues()\n\n    // Only prefetch options and faceted values for option and multi-option columns\n    if (isAnyOf(column.type, ['option', 'multiOption'])) {\n      column.prefetchOptions()\n      column.prefetchFacetedUniqueValues()\n    }\n\n    // Only prefetch min/max values for number columns\n    if (column.type === 'number') {\n      column.prefetchFacetedMinMaxValues()\n    }\n  }, [column])\n\n  useEffect(() => {\n    const target = itemRef.current\n\n    if (!target) return\n\n    // Set up MutationObserver\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'attributes') {\n          const isSelected = target.getAttribute('data-selected') === 'true'\n          if (isSelected) prefetch()\n        }\n      }\n    })\n\n    // Set up observer\n    observer.observe(target, {\n      attributes: true,\n      attributeFilter: ['data-selected'],\n    })\n\n    // Cleanup on unmount\n    return () => observer.disconnect()\n  }, [prefetch])\n\n  return (\n    <CommandItem\n      ref={itemRef}\n      value={column.id}\n      keywords={[column.displayName]}\n      onSelect={() => setProperty(column.id)}\n      className=\"group\"\n      onMouseEnter={prefetch}\n    >\n      <div className=\"flex w-full items-center justify-between\">\n        <div className=\"inline-flex items-center gap-1.5\">\n          {hasIcon &&\n            (isValidElement(Icon) ? (\n              Icon\n            ) : (\n              <Icon className=\"size-4 stroke-[2.25px]\" />\n            ))}\n          <span>{column.displayName}</span>\n        </div>\n        <ArrowRightIcon className=\"size-4 opacity-0 group-aria-selected:opacity-100\" />\n      </div>\n    </CommandItem>\n  )\n}\n\ninterface QuickSearchFiltersProps<TData> {\n  search?: string\n  filters: FiltersState\n  columns: Column<TData>[]\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n  locale?: Locale\n}\n\nexport const QuickSearchFilters = memo(\n  __QuickSearchFilters,\n) as typeof __QuickSearchFilters\n\nfunction __QuickSearchFilters<TData>({\n  search,\n  filters,\n  columns,\n  actions,\n  strategy,\n  locale = 'en',\n}: QuickSearchFiltersProps<TData>) {\n  if (!search || search.trim().length < 2) return null\n\n  // biome-ignore lint/correctness/useHookAtTopLevel: its okay\n  const cols = useMemo(\n    () =>\n      columns.filter((c) =>\n        isAnyOf<ColumnDataType>(c.type, ['option', 'multiOption']),\n      ),\n    [columns],\n  )\n\n  return (\n    <>\n      {cols.map((column) => {\n        const filter = filters.find((f) => f.columnId === column.id)\n        const options = column.getOptions()\n        const optionsCount = column.getFacetedUniqueValues()\n\n        function handleOptionSelect(value: string, check: boolean) {\n          if (check) actions.addFilterValue(column, [value])\n          else actions.removeFilterValue(column, [value])\n        }\n\n        return (\n          <React.Fragment key={column.id}>\n            {options.map((v) => {\n              const checked = Boolean(filter?.values.includes(v.value))\n              const count = optionsCount?.get(v.value) ?? 0\n\n              return (\n                <CommandItem\n                  key={v.value}\n                  value={v.value}\n                  keywords={[v.label, v.value]}\n                  onSelect={() => {\n                    handleOptionSelect(v.value, !checked)\n                  }}\n                  className=\"group\"\n                >\n                  <div className=\"flex items-center gap-1.5 group\">\n                    <Checkbox\n                      checked={checked}\n                      className=\"opacity-0 data-[state=checked]:opacity-100 group-data-[selected=true]:opacity-100 dark:border-ring mr-1\"\n                    />\n                    <div className=\"flex items-center w-4 justify-center\">\n                      {v.icon &&\n                        (isValidElement(v.icon) ? (\n                          v.icon\n                        ) : (\n                          <v.icon className=\"size-4 text-primary\" />\n                        ))}\n                    </div>\n                    <div className=\"flex items-center gap-0.5\">\n                      <span className=\"text-muted-foreground\">\n                        {column.displayName}\n                      </span>\n                      <ChevronRightIcon className=\"size-3.5 text-muted-foreground/75\" />\n                      <span>\n                        {v.label}\n                        <sup\n                          className={cn(\n                            !optionsCount && 'hidden',\n                            'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\n                            count === 0 && 'slashed-zero',\n                          )}\n                        >\n                          {count < 100 ? count : '100+'}\n                        </sup>\n                      </span>\n                    </div>\n                  </div>\n                </CommandItem>\n              )\n            })}\n          </React.Fragment>\n        )\n      })}\n    </>\n  )\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-selector.tsx"
    },
    {
      "path": "registry/data-table-filter/components/filter-subject.tsx",
      "content": "import type { Column, ColumnDataType } from '@bazzaui/filters'\nimport { isValidElement } from 'react'\n\ninterface FilterSubjectProps<TData, TType extends ColumnDataType> {\n  column: Column<TData, TType>\n}\n\nexport function FilterSubject<TData, TType extends ColumnDataType>({\n  column,\n}: FilterSubjectProps<TData, TType>) {\n  const { icon: Icon } = column\n  const hasIcon = !!Icon\n\n  return (\n    <span className=\"flex select-none items-center gap-1 whitespace-nowrap px-2 font-medium\">\n      {hasIcon &&\n        (isValidElement(Icon) ? (\n          Icon\n        ) : (\n          <Icon className=\"size-4 text-primary stroke-[2.25px]\" />\n        ))}\n\n      <span>{column.displayName}</span>\n    </span>\n  )\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-subject.tsx"
    },
    {
      "path": "registry/data-table-filter/components/filter-value.tsx",
      "content": "import {\n  type Column,\n  type ColumnDataType,\n  type ColumnOptionExtended,\n  createNumberRange,\n  type DataTableFilterActions,\n  type FilterModel,\n  type FilterStrategy,\n  type Locale,\n  numberFilterOperators,\n  t,\n  take,\n} from '@bazzaui/filters'\nimport { format, isEqual } from 'date-fns'\nimport { Ellipsis } from 'lucide-react'\nimport {\n  cloneElement,\n  isValidElement,\n  memo,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react'\nimport type { DateRange } from 'react-day-picker'\nimport { Button } from '@/components/ui/button'\nimport { Calendar } from '@/components/ui/calendar'\nimport { Checkbox } from '@/components/ui/checkbox'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n  CommandSeparator,\n} from '@/components/ui/command'\nimport {\n  Popover,\n  PopoverAnchor,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\nimport { Slider } from '@/components/ui/slider'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'\nimport { cn } from '@/lib/utils'\nimport { useDebounceCallback } from '../hooks/use-debounce-callback'\nimport { DebouncedInput } from '../ui/debounced-input'\n\ninterface FilterValueProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n  locale?: Locale\n}\n\nexport const FilterValue = memo(__FilterValue) as typeof __FilterValue\n\nfunction __FilterValue<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n  strategy,\n  locale,\n}: FilterValueProps<TData, TType>) {\n  return (\n    <Popover>\n      <PopoverAnchor className=\"h-full\" />\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"ghost\"\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\n        >\n          <FilterValueDisplay\n            filter={filter}\n            column={column}\n            actions={actions}\n            locale={locale}\n          />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        align=\"start\"\n        side=\"bottom\"\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\n      >\n        <FilterValueController\n          filter={filter}\n          column={column}\n          actions={actions}\n          strategy={strategy}\n          locale={locale}\n        />\n      </PopoverContent>\n    </Popover>\n  )\n}\n\ninterface FilterValueDisplayProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n  locale?: Locale\n}\n\nexport function FilterValueDisplay<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueDisplayProps<TData, TType>) {\n  switch (column.type) {\n    case 'option':\n      return (\n        <FilterValueOptionDisplay\n          filter={filter as FilterModel<'option'>}\n          column={column as Column<TData, 'option'>}\n          actions={actions}\n          locale={locale}\n        />\n      )\n    case 'multiOption':\n      return (\n        <FilterValueMultiOptionDisplay\n          filter={filter as FilterModel<'multiOption'>}\n          column={column as Column<TData, 'multiOption'>}\n          actions={actions}\n          locale={locale}\n        />\n      )\n    case 'date':\n      return (\n        <FilterValueDateDisplay\n          filter={filter as FilterModel<'date'>}\n          column={column as Column<TData, 'date'>}\n          actions={actions}\n          locale={locale}\n        />\n      )\n    case 'text':\n      return (\n        <FilterValueTextDisplay\n          filter={filter as FilterModel<'text'>}\n          column={column as Column<TData, 'text'>}\n          actions={actions}\n          locale={locale}\n        />\n      )\n    case 'number':\n      return (\n        <FilterValueNumberDisplay\n          filter={filter as FilterModel<'number'>}\n          column={column as Column<TData, 'number'>}\n          actions={actions}\n          locale={locale}\n        />\n      )\n    default:\n      return null\n  }\n}\n\nexport function FilterValueOptionDisplay<TData>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueDisplayProps<TData, 'option'>) {\n  const options = useMemo(() => column.getOptions(), [column])\n  const selected = options.filter((o) => filter?.values.includes(o.value))\n\n  // We display the selected options based on how many are selected\n  //\n  // If there is only one option selected, we display its icon and label\n  //\n  // If there are multiple options selected, we display:\n  // 1) up to 3 icons of the selected options\n  // 2) the number of selected options\n  if (selected.length === 1 && selected[0]) {\n    const { label, icon: Icon } = selected[0]\n    const hasIcon = !!Icon\n    return (\n      <span className=\"inline-flex items-center gap-1\">\n        {hasIcon &&\n          (isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon className=\"size-4 text-primary\" />\n          ))}\n        <span>{label}</span>\n      </span>\n    )\n  }\n  const name = column.displayName.toLowerCase()\n  // TODO: Better pluralization for different languages\n  const pluralName = name.endsWith('s') ? `${name}es` : `${name}s`\n\n  const hasOptionIcons = !options?.some((o) => !o.icon)\n\n  return (\n    <div className=\"inline-flex items-center gap-0.5\">\n      {hasOptionIcons &&\n        take(selected, 3).map(({ value, icon }) => {\n          const Icon = icon!\n          return isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon key={value} className=\"size-4\" />\n          )\n        })}\n      <span className={cn(hasOptionIcons && 'ml-1.5')}>\n        {selected.length} {pluralName}\n      </span>\n    </div>\n  )\n}\n\nexport function FilterValueMultiOptionDisplay<TData>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueDisplayProps<TData, 'multiOption'>) {\n  const options = useMemo(() => column.getOptions(), [column])\n  const selected = options.filter((o) => filter.values.includes(o.value))\n\n  if (selected.length === 1 && selected[0]) {\n    const { label, icon: Icon } = selected[0]\n    const hasIcon = !!Icon\n    return (\n      <span className=\"inline-flex items-center gap-1.5\">\n        {hasIcon &&\n          (isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon className=\"size-4 text-primary\" />\n          ))}\n\n        <span>{label}</span>\n      </span>\n    )\n  }\n\n  const name = column.displayName.toLowerCase()\n\n  const hasOptionIcons = !options?.some((o) => !o.icon)\n\n  return (\n    <div className=\"inline-flex items-center gap-1.5\">\n      {hasOptionIcons && (\n        <div key=\"icons\" className=\"inline-flex items-center gap-0.5\">\n          {take(selected, 3).map(({ value, icon }) => {\n            const Icon = icon!\n            return isValidElement(Icon) ? (\n              cloneElement(Icon, { key: value })\n            ) : (\n              <Icon key={value} className=\"size-4\" />\n            )\n          })}\n        </div>\n      )}\n      <span>\n        {selected.length} {name}\n      </span>\n    </div>\n  )\n}\n\nfunction formatDateRange(start: Date, end: Date) {\n  const sameMonth = start.getMonth() === end.getMonth()\n  const sameYear = start.getFullYear() === end.getFullYear()\n\n  if (sameMonth && sameYear) {\n    return `${format(start, 'MMM d')} - ${format(end, 'd, yyyy')}`\n  }\n\n  if (sameYear) {\n    return `${format(start, 'MMM d')} - ${format(end, 'MMM d, yyyy')}`\n  }\n\n  return `${format(start, 'MMM d, yyyy')} - ${format(end, 'MMM d, yyyy')}`\n}\n\nexport function FilterValueDateDisplay<TData>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueDisplayProps<TData, 'date'>) {\n  if (!filter) return null\n  if (filter.values.length === 0) return <Ellipsis className=\"size-4\" />\n  if (filter.values.length === 1 && filter.values[0]) {\n    const value = filter.values[0]\n\n    const formattedDateStr = format(value, 'MMM d, yyyy')\n\n    return <span>{formattedDateStr}</span>\n  }\n  if (filter.values.length === 2 && filter.values[0] && filter.values[1]) {\n    const formattedRangeStr = formatDateRange(\n      filter.values[0],\n      filter.values[1],\n    )\n\n    return <span>{formattedRangeStr}</span>\n  }\n\n  return null\n}\n\nexport function FilterValueTextDisplay<TData>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueDisplayProps<TData, 'text'>) {\n  if (!filter) return null\n  if (\n    filter.values.length === 0 ||\n    (filter.values[0] && filter.values[0].trim() === '')\n  )\n    return <Ellipsis className=\"size-4\" />\n\n  const value = filter.values[0]\n\n  return <span>{value}</span>\n}\n\nexport function FilterValueNumberDisplay<TData>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueDisplayProps<TData, 'number'>) {\n  if (!filter || !filter.values || filter.values.length === 0) return null\n\n  if (\n    filter.operator === 'is between' ||\n    filter.operator === 'is not between'\n  ) {\n    const minValue = filter.values[0]\n    const maxValue = filter.values[1]\n\n    return (\n      <span className=\"tabular-nums tracking-tight\">\n        {minValue} {t('and', locale)} {maxValue}\n      </span>\n    )\n  }\n\n  const value = filter.values[0]\n  return <span className=\"tabular-nums tracking-tight\">{value}</span>\n}\n\n/****** Property Filter Value Controller ******/\n\ninterface FilterValueControllerProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n  locale?: Locale\n}\n\nexport const FilterValueController = memo(\n  __FilterValueController,\n) as typeof __FilterValueController\n\nfunction __FilterValueController<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n  strategy,\n  locale = 'en',\n}: FilterValueControllerProps<TData, TType>) {\n  switch (column.type) {\n    case 'option':\n      return (\n        <FilterValueOptionController\n          filter={filter as FilterModel<'option'>}\n          column={column as Column<TData, 'option'>}\n          actions={actions}\n          strategy={strategy}\n          locale={locale}\n        />\n      )\n    case 'multiOption':\n      return (\n        <FilterValueMultiOptionController\n          filter={filter as FilterModel<'multiOption'>}\n          column={column as Column<TData, 'multiOption'>}\n          actions={actions}\n          strategy={strategy}\n          locale={locale}\n        />\n      )\n    case 'date':\n      return (\n        <FilterValueDateController\n          filter={filter as FilterModel<'date'>}\n          column={column as Column<TData, 'date'>}\n          actions={actions}\n          strategy={strategy}\n          locale={locale}\n        />\n      )\n    case 'text':\n      return (\n        <FilterValueTextController\n          filter={filter as FilterModel<'text'>}\n          column={column as Column<TData, 'text'>}\n          actions={actions}\n          strategy={strategy}\n          locale={locale}\n        />\n      )\n    case 'number':\n      return (\n        <FilterValueNumberController\n          filter={filter as FilterModel<'number'>}\n          column={column as Column<TData, 'number'>}\n          actions={actions}\n          strategy={strategy}\n          locale={locale}\n        />\n      )\n    default:\n      return null\n  }\n}\n\ninterface OptionItemProps {\n  option: ColumnOptionExtended\n  onToggle: (value: string, checked: boolean) => void\n}\n\n// Memoized option item to prevent re-renders unless its own props change\nconst OptionItem = memo(function OptionItem({\n  option,\n  onToggle,\n}: OptionItemProps) {\n  const { value, label, icon: Icon, selected, count } = option\n  const handleSelect = useCallback(() => {\n    onToggle(value, !selected)\n  }, [onToggle, value, selected])\n\n  return (\n    <CommandItem\n      key={value}\n      onSelect={handleSelect}\n      className=\"group flex items-center justify-between gap-1.5\"\n    >\n      <div className=\"flex items-center gap-1.5\">\n        <Checkbox\n          checked={selected}\n          className=\"opacity-0 data-[state=checked]:opacity-100 group-data-[selected=true]:opacity-100 dark:border-ring mr-1\"\n        />\n        {Icon &&\n          (isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon className=\"size-4 text-primary\" />\n          ))}\n        <span>\n          {label}\n          <sup\n            className={cn(\n              count == null && 'hidden',\n              'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\n              count === 0 && 'slashed-zero',\n            )}\n          >\n            {typeof count === 'number'\n              ? new Intl.NumberFormat().format(count)\n              : ''}\n          </sup>\n        </span>\n      </div>\n    </CommandItem>\n  )\n})\n\nexport function FilterValueOptionController<TData>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueControllerProps<TData, 'option'>) {\n  // Derive the initial selected values on mount\n  const initialSelectedValues = useMemo(() => new Set(filter?.values || []), [])\n\n  // Separate the selected and unselected options\n  const { selectedOptions, unselectedOptions } = useMemo(() => {\n    const counts = column.getFacetedUniqueValues()\n    const allOptions = column.getOptions().map((o) => {\n      const currentlySelected = filter?.values.includes(o.value) ?? false\n      return {\n        ...o,\n        selected: currentlySelected,\n        count: counts?.get(o.value) ?? 0,\n      }\n    })\n\n    const selected = allOptions.filter((o) =>\n      initialSelectedValues.has(o.value),\n    )\n    const unselected = allOptions.filter(\n      (o) => !initialSelectedValues.has(o.value),\n    )\n    return { selectedOptions: selected, unselectedOptions: unselected }\n  }, [column, filter?.values, initialSelectedValues])\n\n  const handleToggle = useCallback(\n    (value: string, checked: boolean) => {\n      if (checked) actions.addFilterValue(column, [value])\n      else actions.removeFilterValue(column, [value])\n    },\n    [actions, column],\n  )\n\n  return (\n    <Command loop>\n      <CommandInput autoFocus placeholder={t('search', locale)} />\n      <CommandEmpty>{t('noresults', locale)}</CommandEmpty>\n      <CommandList className=\"max-h-fit\">\n        <CommandGroup className={cn(selectedOptions.length === 0 && 'hidden')}>\n          {selectedOptions.map((option) => (\n            <OptionItem\n              key={option.value}\n              option={option}\n              onToggle={handleToggle}\n            />\n          ))}\n        </CommandGroup>\n        <CommandSeparator />\n        <CommandGroup\n          className={cn(unselectedOptions.length === 0 && 'hidden')}\n        >\n          {unselectedOptions.map((option) => (\n            <OptionItem\n              key={option.value}\n              option={option}\n              onToggle={handleToggle}\n            />\n          ))}\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function FilterValueMultiOptionController<TData>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueControllerProps<TData, 'multiOption'>) {\n  // Derive the initial selected values on mount\n  const initialSelectedValues = useMemo(() => new Set(filter?.values || []), [])\n\n  // Separate the selected and unselected options\n  const { selectedOptions, unselectedOptions } = useMemo(() => {\n    const counts = column.getFacetedUniqueValues()\n    const allOptions = column.getOptions().map((o) => {\n      const currentlySelected = filter?.values.includes(o.value) ?? false\n      return {\n        ...o,\n        selected: currentlySelected,\n        count: counts?.get(o.value) ?? 0,\n      }\n    })\n\n    const selected = allOptions.filter((o) =>\n      initialSelectedValues.has(o.value),\n    )\n    const unselected = allOptions.filter(\n      (o) => !initialSelectedValues.has(o.value),\n    )\n    return { selectedOptions: selected, unselectedOptions: unselected }\n  }, [column, filter?.values, initialSelectedValues])\n\n  const handleToggle = useCallback(\n    (value: string, checked: boolean) => {\n      if (checked) actions.addFilterValue(column, [value])\n      else actions.removeFilterValue(column, [value])\n    },\n    [actions, column],\n  )\n\n  return (\n    <Command loop>\n      <CommandInput autoFocus placeholder={t('search', locale)} />\n      <CommandEmpty>{t('noresults', locale)}</CommandEmpty>\n      <CommandList>\n        <CommandGroup className={cn(selectedOptions.length === 0 && 'hidden')}>\n          {selectedOptions.map((option) => (\n            <OptionItem\n              key={option.value}\n              option={option}\n              onToggle={handleToggle}\n            />\n          ))}\n        </CommandGroup>\n        <CommandSeparator />\n        <CommandGroup\n          className={cn(unselectedOptions.length === 0 && 'hidden')}\n        >\n          {unselectedOptions.map((option) => (\n            <OptionItem\n              key={option.value}\n              option={option}\n              onToggle={handleToggle}\n            />\n          ))}\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function FilterValueDateController<TData>({\n  filter,\n  column,\n  actions,\n}: FilterValueControllerProps<TData, 'date'>) {\n  const [date, setDate] = useState<DateRange | undefined>({\n    from: filter?.values[0] ?? new Date(),\n    to: filter?.values[1] ?? undefined,\n  })\n\n  function changeDateRange(value: DateRange | undefined) {\n    const start = value?.from\n    const end =\n      start && value && value.to && !isEqual(start, value.to)\n        ? value.to\n        : undefined\n\n    setDate({ from: start, to: end })\n\n    const isRange = start && end\n    const newValues = isRange ? [start, end] : start ? [start] : []\n\n    actions.setFilterValue(column, newValues)\n  }\n\n  return (\n    <Command>\n      <CommandList className=\"max-h-fit\">\n        <CommandGroup>\n          <div>\n            <Calendar\n              initialFocus\n              mode=\"range\"\n              defaultMonth={date?.from}\n              selected={date}\n              onSelect={changeDateRange}\n              numberOfMonths={1}\n            />\n          </div>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function FilterValueTextController<TData>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueControllerProps<TData, 'text'>) {\n  const changeText = (value: string | number) => {\n    actions.setFilterValue(column, [String(value)])\n  }\n\n  return (\n    <Command>\n      <CommandList className=\"max-h-fit\">\n        <CommandGroup>\n          <CommandItem>\n            <DebouncedInput\n              placeholder={t('search', locale)}\n              autoFocus\n              value={filter?.values[0] ?? ''}\n              onChange={changeText}\n            />\n          </CommandItem>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function FilterValueNumberController<TData>({\n  filter,\n  column,\n  actions,\n  locale = 'en',\n}: FilterValueControllerProps<TData, 'number'>) {\n  const minMax = useMemo(() => column.getFacetedMinMaxValues(), [column])\n  const [sliderMin, sliderMax] = [\n    minMax ? minMax[0] : 0,\n    minMax ? minMax[1] : 0,\n  ]\n\n  // Local state for values\n  const [values, setValues] = useState(filter?.values ?? [0, 0])\n\n  // Sync with parent filter changes\n  useEffect(() => {\n    if (\n      filter?.values &&\n      filter.values.length === values.length &&\n      filter.values.every((v, i) => v === values[i])\n    ) {\n      setValues(filter.values)\n    }\n  }, [filter?.values, values])\n\n  const isNumberRange =\n    // filter && values.length === 2\n    filter && numberFilterOperators[filter.operator].target === 'multiple'\n\n  const setFilterOperatorDebounced = useDebounceCallback(\n    actions.setFilterOperator,\n    500,\n  )\n  const setFilterValueDebounced = useDebounceCallback(\n    actions.setFilterValue,\n    500,\n  )\n\n  const changeNumber = (value: number[]) => {\n    setValues(value)\n    setFilterValueDebounced(column as any, value)\n  }\n\n  const changeMinNumber = (value: number) => {\n    const newValues = createNumberRange([value, values[1]!])\n    setValues(newValues)\n    setFilterValueDebounced(column as any, newValues)\n  }\n\n  const changeMaxNumber = (value: number) => {\n    const newValues = createNumberRange([values[0]!, value])\n    setValues(newValues)\n    setFilterValueDebounced(column as any, newValues)\n  }\n\n  const changeType = useCallback(\n    (type: 'single' | 'range') => {\n      let newValues: number[] = []\n      if (type === 'single')\n        newValues = [values[0]!] // Keep the first value for single mode\n      else if (!minMax)\n        newValues = createNumberRange([values[0]!, values[1] ?? 0])\n      else {\n        const value = values[0]!\n        newValues =\n          value - minMax[0] < minMax[1] - value\n            ? createNumberRange([value, minMax[1]])\n            : createNumberRange([minMax[0], value])\n      }\n\n      const newOperator = type === 'single' ? 'is' : 'is between'\n\n      // Update local state\n      setValues(newValues)\n\n      // Cancel in-flight debounced calls to prevent flicker/race conditions\n      setFilterOperatorDebounced.cancel()\n      setFilterValueDebounced.cancel()\n\n      // Update global filter state atomically\n      actions.setFilterOperator(column.id, newOperator)\n      actions.setFilterValue(column, newValues)\n    },\n    [values, column, actions, minMax],\n  )\n\n  return (\n    <Command>\n      <CommandList className=\"w-[300px] px-2 py-2\">\n        <CommandGroup>\n          <div className=\"flex flex-col w-full\">\n            <Tabs\n              value={isNumberRange ? 'range' : 'single'}\n              onValueChange={(v) => changeType(v as 'single' | 'range')}\n            >\n              <TabsList className=\"w-full *:text-xs\">\n                <TabsTrigger value=\"single\">{t('single', locale)}</TabsTrigger>\n                <TabsTrigger value=\"range\">{t('range', locale)}</TabsTrigger>\n              </TabsList>\n              <TabsContent value=\"single\" className=\"flex flex-col gap-4 mt-4\">\n                {minMax && (\n                  <Slider\n                    value={[values[0]!]}\n                    onValueChange={(value) => changeNumber(value)}\n                    min={sliderMin}\n                    max={sliderMax}\n                    step={1}\n                    aria-orientation=\"horizontal\"\n                  />\n                )}\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"text-xs font-medium\">\n                    {t('value', locale)}\n                  </span>\n                  <DebouncedInput\n                    id=\"single\"\n                    type=\"number\"\n                    value={values[0]!.toString()} // Use values[0] directly\n                    onChange={(v) => changeNumber([Number(v)])}\n                  />\n                </div>\n              </TabsContent>\n              <TabsContent value=\"range\" className=\"flex flex-col gap-4 mt-4\">\n                {minMax && (\n                  <Slider\n                    value={values} // Use values directly\n                    onValueChange={changeNumber}\n                    min={sliderMin}\n                    max={sliderMax}\n                    step={1}\n                    aria-orientation=\"horizontal\"\n                  />\n                )}\n                <div className=\"grid grid-cols-2 gap-4\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-xs font-medium\">\n                      {t('min', locale)}\n                    </span>\n                    <DebouncedInput\n                      type=\"number\"\n                      value={values[0]!}\n                      onChange={(v) => changeMinNumber(Number(v))}\n                    />\n                  </div>\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-xs font-medium\">\n                      {t('max', locale)}\n                    </span>\n                    <DebouncedInput\n                      type=\"number\"\n                      value={values[1]!}\n                      onChange={(v) => changeMaxNumber(Number(v))}\n                    />\n                  </div>\n                </div>\n              </TabsContent>\n            </Tabs>\n          </div>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-value.tsx"
    },
    {
      "path": "registry/data-table-filter/hooks/use-debounce-callback.tsx",
      "content": "/*\n * Source: https://usehooks-ts.com/react-hook/use-debounce-callback\n */\n\nimport { useEffect, useMemo, useRef } from 'react'\nimport { debounce } from '../lib/debounce'\nimport { useUnmount } from './use-unmount'\n\ntype DebounceOptions = {\n  leading?: boolean\n  trailing?: boolean\n  maxWait?: number\n}\n\ntype ControlFunctions = {\n  cancel: () => void\n  flush: () => void\n  isPending: () => boolean\n}\n\nexport type DebouncedState<T extends (...args: any) => ReturnType<T>> = ((\n  ...args: Parameters<T>\n) => ReturnType<T> | undefined) &\n  ControlFunctions\n\nexport function useDebounceCallback<T extends (...args: any) => ReturnType<T>>(\n  func: T,\n  delay = 500,\n  options?: DebounceOptions,\n): DebouncedState<T> {\n  const debouncedFunc = useRef<ReturnType<typeof debounce>>(null)\n\n  useUnmount(() => {\n    if (debouncedFunc.current) {\n      debouncedFunc.current.cancel()\n    }\n  })\n\n  const debounced = useMemo(() => {\n    const debouncedFuncInstance = debounce(func, delay, options)\n\n    const wrappedFunc: DebouncedState<T> = (...args: Parameters<T>) => {\n      return debouncedFuncInstance(...args)\n    }\n\n    wrappedFunc.cancel = () => {\n      debouncedFuncInstance.cancel()\n    }\n\n    wrappedFunc.isPending = () => {\n      return !!debouncedFunc.current\n    }\n\n    wrappedFunc.flush = () => {\n      return debouncedFuncInstance.flush()\n    }\n\n    return wrappedFunc\n  }, [func, delay, options])\n\n  // Update the debounced function ref whenever func, wait, or options change\n  useEffect(() => {\n    debouncedFunc.current = debounce(func, delay, options)\n  }, [func, delay, options])\n\n  return debounced\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/hooks/use-debounce-callback.tsx"
    },
    {
      "path": "registry/data-table-filter/hooks/use-unmount.tsx",
      "content": "/*\n * Source: https://usehooks-ts.com/react-hook/use-unmount\n */\n\nimport { useEffect, useRef } from 'react'\n\nexport function useUnmount(func: () => void) {\n  const funcRef = useRef(func)\n\n  funcRef.current = func\n\n  useEffect(\n    () => () => {\n      funcRef.current()\n    },\n    [],\n  )\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/hooks/use-unmount.tsx"
    },
    {
      "path": "registry/data-table-filter/lib/debounce.ts",
      "content": "type ControlFunctions = {\n  cancel: () => void\n  flush: () => void\n  isPending: () => boolean\n}\n\ntype DebounceOptions = {\n  leading?: boolean\n  trailing?: boolean\n  maxWait?: number\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number,\n  options: DebounceOptions = {},\n): ((...args: Parameters<T>) => ReturnType<T> | undefined) & ControlFunctions {\n  const { leading = false, trailing = true, maxWait } = options\n  let timeout: NodeJS.Timeout | null = null\n  let lastArgs: Parameters<T> | null = null\n  let lastThis: any\n  let result: ReturnType<T> | undefined\n  let lastCallTime: number | null = null\n  let lastInvokeTime = 0\n\n  const maxWaitTime = maxWait !== undefined ? Math.max(wait, maxWait) : null\n\n  function invokeFunc(time: number): ReturnType<T> | undefined {\n    if (lastArgs === null) return undefined\n    const args = lastArgs\n    const thisArg = lastThis\n    lastArgs = null\n    lastThis = null\n    lastInvokeTime = time\n    result = func.apply(thisArg, args)\n    return result\n  }\n\n  function shouldInvoke(time: number): boolean {\n    if (lastCallTime === null) return false\n    const timeSinceLastCall = time - lastCallTime\n    const timeSinceLastInvoke = time - lastInvokeTime\n    return (\n      lastCallTime === null ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxWaitTime !== null && timeSinceLastInvoke >= maxWaitTime)\n    )\n  }\n\n  function startTimer(\n    pendingFunc: () => void,\n    waitTime: number,\n  ): NodeJS.Timeout {\n    return setTimeout(pendingFunc, waitTime)\n  }\n\n  function remainingWait(time: number): number {\n    if (lastCallTime === null) return wait\n    const timeSinceLastCall = time - lastCallTime\n    const timeSinceLastInvoke = time - lastInvokeTime\n    const timeWaiting = wait - timeSinceLastCall\n    return maxWaitTime !== null\n      ? Math.min(timeWaiting, maxWaitTime - timeSinceLastInvoke)\n      : timeWaiting\n  }\n\n  function timerExpired() {\n    const time = Date.now()\n    if (shouldInvoke(time)) {\n      return trailingEdge(time)\n    }\n    timeout = startTimer(timerExpired, remainingWait(time))\n  }\n\n  function leadingEdge(time: number): ReturnType<T> | undefined {\n    lastInvokeTime = time\n    timeout = startTimer(timerExpired, wait)\n    return leading ? invokeFunc(time) : undefined\n  }\n\n  function trailingEdge(time: number): ReturnType<T> | undefined {\n    timeout = null\n    if (trailing && lastArgs) {\n      return invokeFunc(time)\n    }\n    lastArgs = null\n    lastThis = null\n    return result\n  }\n\n  function debounced(\n    this: any,\n    ...args: Parameters<T>\n  ): ReturnType<T> | undefined {\n    const time = Date.now()\n    const isInvoking = shouldInvoke(time)\n\n    lastArgs = args\n    lastThis = this\n    lastCallTime = time\n\n    if (isInvoking) {\n      if (timeout === null) {\n        return leadingEdge(lastCallTime)\n      }\n      if (maxWaitTime !== null) {\n        timeout = startTimer(timerExpired, wait)\n        return invokeFunc(lastCallTime)\n      }\n    }\n    if (timeout === null) {\n      timeout = startTimer(timerExpired, wait)\n    }\n    return result\n  }\n\n  debounced.cancel = () => {\n    if (timeout !== null) {\n      clearTimeout(timeout)\n    }\n    lastInvokeTime = 0\n    lastArgs = null\n    lastThis = null\n    lastCallTime = null\n    timeout = null\n  }\n\n  debounced.flush = () => {\n    return timeout === null ? result : trailingEdge(Date.now())\n  }\n\n  debounced.isPending = () => {\n    return timeout !== null\n  }\n\n  return debounced\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/lib/debounce.ts"
    },
    {
      "path": "registry/data-table-filter/ui/debounced-input.tsx",
      "content": "'use client'\n\nimport { Input } from '@/components/ui/input'\nimport { useCallback, useEffect, useState } from 'react'\nimport { debounce } from '../lib/debounce'\n\nexport function DebouncedInput({\n  value: initialValue,\n  onChange,\n  debounceMs = 500, // This is the wait time, not the function\n  ...props\n}: {\n  value: string | number\n  onChange: (value: string | number) => void\n  debounceMs?: number\n} & Omit<React.InputHTMLAttributes<HTMLInputElement>, 'onChange'>) {\n  const [value, setValue] = useState(initialValue)\n\n  // Sync with initialValue when it changes\n  useEffect(() => {\n    setValue(initialValue)\n  }, [initialValue])\n\n  // Define the debounced function with useCallback\n  const debouncedOnChange = useCallback(\n    debounce((newValue: string | number) => {\n      onChange(newValue)\n    }, debounceMs), // Pass the wait time here\n    [debounceMs, onChange], // Dependencies\n  )\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value\n    setValue(newValue) // Update local state immediately\n    debouncedOnChange(newValue) // Call debounced version\n  }\n\n  return <Input {...props} value={value} onChange={handleChange} />\n}\n",
      "type": "registry:file",
      "target": "components/data-table-filter/ui/debounced-input.tsx"
    }
  ]
}
