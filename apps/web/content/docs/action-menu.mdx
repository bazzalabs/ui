---
title: Action menu
section: Components
summary: A composable, searchable, multi-level action menu with submenus, fuzzy search, and full control over rendering.
badge: alpha
---

## Introduction

The **Action Menu** is a headless, renderer-driven command/menu surface for actions. It’s built on Radix Primitives and Popper, supports multi-level submenus, **deep search** (across nested submenus), **Vim-style shortcuts**, RTL, and a **slot** system that lets you fully control the markup and styling of items, lists, inputs, and content wrappers.

Highlights:

* **Typed menus** with payloads (`createActionMenu<T>()`) so your row renderers and callbacks are type-safe.
* **Deep, scored search** (fuzzyish) that can match items and submenus and surface breadcrumb context.
* **Great keyboard UX**: roving focus, `aria-activedescendant`, Vim binds (Ctrl-N/P/J/K), Home/End/PageUp/PageDown, and RTL-aware open/close keys.
* **Smart submenu hover** with an *aim guard* (predicts pointer trajectory to avoid accidental closes).
* **Per-submenu UI overrides**: slots, slotProps, classNames can be customized at any level.

## Installation

The Action Menu is distributed via the `shadcn` registry and ships with sensible defaults. It uses Radix UI under the hood.

```bash
# Install the UI files into your project
npx shadcn@latest add https://ui.bazza.dev/r/action-menu
```

> \[!NOTE]
> The component depends on Radix UI packages and your project’s `cn()` utility (like the standard shadcn **cn** helper). The registry installer adds what you need; if you’re integrating manually, make sure Radix and your `cn` helper are available.

## Quick Start

Here’s the smallest useful example—root menu + trigger + positioned content—with a couple of actions and a submenu.

```tsx
'use client'

import * as AM from '@/components/action-menu' // Root, Trigger, Positioner, Content
import type { MenuData, ItemNode, SubmenuNode } from '@/components/action-menu/types'
import { SettingsIcon, Trash2Icon, UserIcon } from 'lucide-react'

type Action = { id: string } // payload carried by items (optional)

const menu: MenuData<Action> = {
  id: 'root',
  title: 'Actions',
  inputPlaceholder: 'Filter actions…',
  nodes: [
    // a simple item
    {
      kind: 'item',
      id: 'rename',
      label: 'Rename',
      icon: SettingsIcon,
      onSelect: () => console.log('Rename selected'),
    },
    // a submenu with its own children
    {
      kind: 'submenu',
      id: 'user',
      title: 'User',
      icon: UserIcon,
      nodes: [
        { kind: 'item', id: 'assign', label: 'Assign…', onSelect: () => {} },
        { kind: 'item', id: 'unassign', label: 'Unassign', onSelect: () => {} },
      ],
    } as SubmenuNode<Action>,
    // a destructive action
    {
      kind: 'item',
      id: 'delete',
      label: 'Delete',
      icon: Trash2Icon,
      onSelect: () => console.log('Delete selected'),
    } as ItemNode<Action>,
  ],
}

export default function Example() {
  return (
    <AM.Root>
      <AM.Trigger className="inline-flex items-center gap-2 rounded-md px-3 py-2 border">
        Open menu
      </AM.Trigger>

      <AM.Positioner side="bottom" align="start">
        <AM.Content menu={menu} />
      </AM.Positioner>
    </AM.Root>
  )
}
```

### Type-safe Content via a factory (recommended)

If your items carry a payload (e.g., the selected entity), get a typed `<Content />` with `createActionMenu<T>()`:

```tsx
import { createActionMenu } from '@/components/action-menu'

type IssueAction = { issueId: string }

const AM = createActionMenu<IssueAction>()

export function TypedExample() {
  return (
    <AM.Root>
      <AM.Trigger>Open</AM.Trigger>
      <AM.Positioner>
        <AM.Content menu={menu /* typed MenuData<IssueAction> */} />
      </AM.Positioner>
    </AM.Root>
  )
}
```

## Concepts

### Data model

You describe each surface as `MenuData<T>` with `nodes` that are `item`, `group`, or `submenu`:

```ts
type MenuNodeKind = 'item' | 'group' | 'submenu'

type ItemNode<T = unknown> = {
  kind: 'item'
  id: string
  label?: string
  icon?: React.ElementType | React.ReactNode
  keywords?: string[]           // extra search terms
  render?: () => React.ReactNode // optional custom renderer for this row
  data?: T                       // payload for your app logic
  onSelect?: () => void
}

type GroupNode<T = unknown> = {
  kind: 'group'
  id: string
  heading?: string
  nodes: Array<ItemNode<T> | SubmenuNode<any>>
}

type SubmenuNode<T = unknown, TChild = unknown> = {
  kind: 'submenu'
  id: string
  title?: string                 // shown by default if no render()
  label?: string                 // used by search
  keywords?: string[]            // used by search
  icon?: React.ElementType | React.ReactNode
  render?: () => React.ReactNode // custom row renderer for the subtrigger
  data?: T
  inputPlaceholder?: string
  hideSearchUntilActive?: boolean
  nodes: MenuNode<TChild>[]
  ui?: {
    slots?: Partial<MenuSlots<TChild>>
    slotProps?: Partial<MenuSlotProps>
    classNames?: Partial<SlotClassNames>
  }
}

type MenuData<T = unknown> = {
  id: string
  title?: string
  inputPlaceholder?: string
  hideSearchUntilActive?: boolean
  nodes?: MenuNode<T>[]
  ui?: {
    slots?: Partial<MenuSlots<T>>
    slotProps?: Partial<MenuSlotProps>
    classNames?: Partial<SlotClassNames>
  }
}
```

> \[!TIP]
> Each submenu can override its **slots**, **slot props**, and **class names** via `node.ui`—useful for sections with different layouts or densities.

### Slots (renderers)

Everything you see is rendered through **slots**:

* `Content` (surface wrapper)
* `Header` (above the input)
* `Input` (combobox search)
* `List` (listbox container)
* `Item` (individual item rows)
* `SubmenuTrigger` (rows that open a submenu)
* `Empty` (empty state)
* `Footer` (below the list)

You can pass slots:

* Globally when you create a typed menu: `createActionMenu({ slots, slotProps, classNames })`
* Per `<Content />` instance: `<Content slots={...} slotProps={...} classNames={...} />`
* Per submenu: in `SubmenuNode.ui`

Each slot receives a **bind API** to wire aria roles/ids and keyboard/mouse events (e.g. `bind.getRowProps()`).

### Deep search

Typing in the input filters current items **and** recursively searches all submenus. Matches inside a submenu are shown inline with breadcrumb info; selecting a matching submenu opens it. You can seed item/submenu searchability with `label` and `keywords`.

### Submenu aim guard

When you move the pointer diagonally toward an open submenu, the menu temporarily **guards** the hovered trigger row so the child submenu doesn’t close while you traverse the “gap”. This is automatic; no config needed.

## Usage

### Customizing the look with slots

Below is a minimal set of slots styled with Tailwind (or your design system). Note the use of `bind.get*Props()` to wire accessibility and interactions.

```tsx
import { cn } from '@/lib/utils'
import { createActionMenu } from '@/components/action-menu'
import { ChevronRight } from 'lucide-react'

const AM = createActionMenu<{ id: string }>({
  classNames: {
    content: 'min-w-[280px] rounded-lg border bg-popover p-2 shadow-md',
    input: 'w-full mb-2 rounded-md border px-2 py-1 text-sm',
    list: 'flex flex-col gap-1 max-h-[320px] overflow-auto',
    item: 'flex items-center gap-2 rounded-md px-2 py-1.5 text-sm hover:bg-accent data-[focused=true]:bg-accent cursor-default',
    subtrigger: 'flex items-center justify-between gap-2 rounded-md px-2 py-1.5 text-sm hover:bg-accent data-[focused=true]:bg-accent cursor-default',
    group: 'mt-2 first:mt-0',
    groupHeading: 'px-2 pb-1 text-[10px] uppercase tracking-wide text-muted-foreground',
  },
  slots: {
    Content: ({ children, bind }) => (
      <div {...bind.getContentProps()} />
    ),
    Input: ({ value, onChange, bind }) => (
      <input {...bind.getInputProps({ value, onChange: e => onChange(e.target.value), placeholder: 'Type to filter…' })} />
    ),
    List: ({ children, bind }) => <div {...bind.getListProps()}>{children}</div>,
    Item: ({ node, bind }) => (
      <div {...bind.getRowProps()}>
        {node.icon && <span aria-hidden>{/* your icon renderer */}</span>}
        <span className="truncate">{node.label ?? node.id}</span>
      </div>
    ),
    SubmenuTrigger: ({ node, bind }) => (
      <div {...bind.getRowProps()}>
        <span className="truncate">{node.label ?? node.title ?? node.id}</span>
        <ChevronRight className="size-4 opacity-60" aria-hidden />
      </div>
    ),
    Empty: ({ query }) => (
      <div className="px-2 py-6 text-sm text-muted-foreground">No results{query ? ` for “${query}”` : ''}.</div>
    ),
  },
})
```

Use it exactly like the base components:

```tsx
<AM.Root>
  <AM.Trigger className="btn">Open</AM.Trigger>
  <AM.Positioner side="bottom" align="start">
    <AM.Content menu={menu} />
  </AM.Positioner>
</AM.Root>
```

### Per-submenu overrides

Give a submenu its own look and feel:

```ts
{
  kind: 'submenu',
  id: 'advanced',
  title: 'Advanced',
  ui: {
    classNames: { content: 'w-[360px]' },
    slots: {
      Header: () => <div className="px-2 pb-1 text-xs text-muted-foreground">Advanced tools</div>,
    },
    slotProps: {
      footer: { className: 'p-2 border-t text-xs text-muted-foreground' },
    },
  },
  nodes: [/* … */],
}
```

### Hiding the input until the user types

On any surface (root or submenu) set:

```ts
hideSearchUntilActive: true
```

Users can start typing while the list owns focus—on first printable key, the input reveals, seeds with that character, and receives focus.

### Positioning

`<Positioner />` wraps the content in Radix Popper. Key props:

* `side`: `'top' | 'right' | 'bottom' | 'left'` (submenu defaults to `'right'`, root to `'bottom'`)
* `align`: `'start' | 'center' | 'end'`
* `alignToFirstItem`: `false | 'on-open' | 'always'` – on submenus, gently offsets so the first row aligns with the trigger row even when an input appears.

```tsx
<AM.Positioner side="right" align="start" alignToFirstItem="always">
  <AM.Content menu={menu} />
</AM.Positioner>
```

## Keyboard & Accessibility

* **Roles**: `menu` (content), `combobox` (input), `listbox` (list), `option` (rows).
* **Focus model**: `aria-activedescendant` + roving focus; input or list owns DOM focus.
* **Keys**:

  * Move: ↑/↓, Home/End, PageUp/PageDown
  * Open/Select: `Enter`, or `→` (LTR) / `←` (RTL) on subtrigger
  * Close/back: `←` (LTR) / `→` (RTL) from a submenu
  * Escape: close submenu or entire menu
  * Vim: `Ctrl-N/J` (next), `Ctrl-P/K` (prev) when enabled
* **Pointer**: Click selects; hover focuses; submenu hover is *guarded* while aiming at an open child.
* **Dismiss**: Click outside or `Escape` (uses Radix Dismissable Layer).
* **RTL**: Respectful of `document.dir` or `dir` prop.

```tsx
<AM.Content
  menu={menu}
  vimBindings={true}
  dir="rtl" // or omit to inherit from document
/>
```

## API Reference

### Components

#### `<ActionMenu.Root />`

Controls open state and provides the anchor for Popper.

```ts
type ActionMenuProps = {
  open?: boolean                 // controlled open state
  defaultOpen?: boolean          // uncontrolled default
  onOpenChange?: (open: boolean) => void
  modal?: boolean                // trap pointer events outside (default: true)
  debug?: boolean                // shows aim zone overlay for submenus
  children: React.ReactNode
}
```

#### `<ActionMenu.Trigger />`

Usually a button. Clicking or pressing `Enter`/`Space` toggles the menu.

```ts
type ActionMenuTriggerProps = React.ComponentPropsWithoutRef<'button'>
```

#### `<ActionMenu.Positioner />`

Positions content relative to the trigger (or subtrigger).

```ts
type ActionMenuPositionerProps = {
  children: React.ReactElement  // typically <ActionMenu.Content />
  side?: 'top' | 'right' | 'bottom' | 'left'
  align?: 'start' | 'center' | 'end'
  sideOffset?: number
  alignOffset?: number
  avoidCollisions?: boolean
  collisionPadding?: number | Partial<Record<'top' | 'right' | 'bottom' | 'left', number>>
  alignToFirstItem?: false | 'on-open' | 'always'
}
```

#### `<ActionMenu.Content />`

Renders a **surface** (input + list + children) for `MenuData<T>`. You may pass slots and class names at this level, or globally via the factory, or per-submenu in `node.ui`.

```ts
type ActionMenuContentProps<T = unknown> = {
  menu: MenuData<T>
  slots?: Partial<MenuSlots<T>>
  slotProps?: Partial<MenuSlotProps>
  classNames?: Partial<SlotClassNames>
  vimBindings?: boolean
  dir?: 'ltr' | 'rtl'
  value?: string                 // controlled query text
  defaultValue?: string          // uncontrolled
  onValueChange?: (value: string) => void
  onOpenAutoFocus?: boolean      // (reserved) whether to focus on open
  onCloseAutoClear?: boolean     // clear query when the root menu closes (default: true)
}
```

### Slots & bind APIs (essentials)

```ts
type MenuSlots<T> = {
  Content: (args: { menu: MenuData<T>; children: React.ReactNode; bind: ContentBindAPI }) => React.ReactNode
  Header?: (args: { menu: MenuData<T> }) => React.ReactNode
  Input: (args: { value: string; onChange: (v: string) => void; bind: InputBindAPI }) => React.ReactNode
  List: (args: { children: React.ReactNode; bind: ListBindAPI }) => React.ReactNode
  Empty?: (args: { query: string }) => React.ReactNode
  Item: (args: { node: ItemNode<T>; search?: SearchContext; bind: RowBindAPI }) => React.ReactNode
  SubmenuTrigger: (args: { node: SubmenuNode<any>; search?: SearchContext; bind: RowBindAPI }) => React.ReactNode
  Footer?: (args: { menu: MenuData<T> }) => React.ReactNode
}

type RowBindAPI = {
  focused: boolean
  disabled: boolean
  getRowProps: <P extends React.HTMLAttributes<HTMLElement>>(overrides?: P) => P & {
    id: string
    role: 'option'
    tabIndex: -1
    'data-action-menu-item-id': string
    'data-focused'?: 'true'
    'aria-selected'?: boolean
    'aria-disabled'?: boolean
  }
}

type InputBindAPI = {
  getInputProps: <P extends React.InputHTMLAttributes<HTMLInputElement>>(overrides?: P) => P & {
    role: 'combobox'
    'aria-autocomplete': 'list'
    'aria-expanded': true
    'aria-controls'?: string
    'aria-activedescendant'?: string
  }
}

type ListBindAPI = {
  getListProps: <P extends React.HTMLAttributes<HTMLElement>>(overrides?: P) => P & {
    role: 'listbox'
    id: string
    tabIndex: number
    'aria-activedescendant'?: string
  }
  getItemOrder: () => string[]
  getActiveId: () => string | null
}
```

> \[!IMPORTANT]
> Always wrap your row JSX in `bind.getRowProps()` (or return an element that spreads those props). This wires roles, ids, focus state, and selection/activation handlers.

## Guides

### 1) Styling rows with icons, descriptions, and shortcuts

```tsx
function Row({ node, bind }: { node: ItemNode; bind: RowBindAPI }) {
  return (
    <div
      {...bind.getRowProps({
        className: cn(
          'flex items-center justify-between gap-3 rounded-md px-2 py-1.5',
          'data-[focused=true]:bg-accent'
        ),
      })}
    >
      <div className="flex items-center gap-2 min-w-0">
        {node.icon && <span className="shrink-0">{/* renderIcon(node.icon) */}</span>}
        <div className="truncate">
          <div className="truncate text-sm">{node.label}</div>
          {/* Optional: <div className="text-xs text-muted-foreground">Description</div> */}
        </div>
      </div>
      {/* Optional: <kbd className="text-xs text-muted-foreground">⌘R</kbd> */}
    </div>
  )
}
```

Pass it as a slot:

```tsx
<AM.Content menu={menu} slots={{ Item: ({ node, bind }) => <Row node={node} bind={bind} /> }} />
```

### 2) Making search feel right

* Provide `label` **and** `keywords` on items/submenus for better matches.
* Set `inputPlaceholder` per surface for contextual prompts.
* Use `hideSearchUntilActive` if you want a “spotlight on type” behavior.

### 3) Controlled open & query

```tsx
const [open, setOpen] = useState(false)
const [query, setQuery] = useState('')

<AM.Root open={open} onOpenChange={setOpen}>
  <AM.Trigger>Open</AM.Trigger>
  <AM.Positioner>
    <AM.Content
      menu={menu}
      value={query}
      onValueChange={setQuery}
      onCloseAutoClear={false}
    />
  </AM.Positioner>
</AM.Root>
```

### 4) Executing actions

Attach logic via `onSelect` on each `ItemNode`. The menu dispatches a synthetic event on `Enter` or click; your `onSelect` runs with no extra glue code.

```ts
{ kind: 'item', id: 'duplicate', label: 'Duplicate', onSelect: () => duplicateThing() }
```

### 5) Nested payloads with different types

Submenus can carry a different payload type than the parent via generics:

```ts
type ProjectAction = { projectId: string }
type UserAction = { userId: string }

const userSubmenu: SubmenuNode<ProjectAction, UserAction> = {
  kind: 'submenu',
  id: 'user',
  title: 'User',
  nodes: [
    { kind: 'item', id: 'assign', label: 'Assign', data: { userId: 'u1' } },
  ],
}
```

## FAQ

**Does it work without an input?**
Yes. If you hide the input, the list gets focus and you can start typing to reveal the input automatically (and seed it).

**How do I align a submenu’s first row with the trigger row?**
Use `<Positioner alignToFirstItem="always" />` (default for submenus) for a subtle offset, even when an input is present.

**What if I want to render a completely custom shell around the content?**
Provide a custom `Content` slot; still spread `bind.getContentProps()` on your outermost element.

**Performance tips?**
Use stable `id`s. Prefer slot functions that are either small or memoized. The search is already optimized and only recalculates when the query changes.

## Changelog

### 2025.08.01

Initial alpha of Action Menu docs and API. Includes typed `createActionMenu<T>()`, deep search, submenu aim guard, and slot/bind architecture.
