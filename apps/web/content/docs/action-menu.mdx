---
title: Action menu
section: Components
summary: "A composable menu with deep search and multi-level submenus."
badge: alpha
---

<ComponentFrame
  className='mb-16'
  containerClassName='h-104'
  caption={<>A subset of <a href="https://linear.app/homepage">Linear</a>'s filter menu, recreated with the bazza/ui action menu.</>}
>
  <Examples.ActionMenu.Linear />
</ComponentFrame>

The action menu is a primitive component for building menu interfaces.

At its core, it combines the best features of the dropdown and command menus available today, while adding deep search capabilities.

## Features

- Data-first API with headless, slot-based rendering.
- Supports submenus with [intent zones](https://linear.app/now/invisible-details) for easy, fluid pointer navigation.
- Deep search across submenus; descendants are searchable from ancestors.
- Fully typed with generics for your own menu data, customizable per submenu.
- Full keyboard navigation with vim-style keybindings built-in.
- Responsive design; renders a dropdown on desktop and a [drawer](https://vaul.emilkowal.ski) on mobile.
- Supports modal and non-modal modes.
- Customize side, alignment, offsets, collision handling.
- Focus is fully managed; follows the `aria-activedescendant` pattern.

## Installation

Want something styled with sensible defaults? Install from our registry with one command.

- Installs the `@bazza-ui/action-menu` package
- Creates the `@/components/ui/action-menu.tsx` file with a styled `ActionMenu` component

```bash
npx shadcn@latest add https://ui.bazza.dev/r/action-menu
```

Install the unstyled, primitive component as an npm package:

```bash
npm install @bazza-ui/action-menu
```

## Data

This component uses a data-first API. You define your menu as a `MenuDef` object and pass it to the `ActionMenu` component:

```tsx
const menu: MenuDef = {
  nodes: [
    { kind: 'item', id: 'Apple', label: 'Apple', icon: 'üçé' },
    { kind: 'item', id: 'Banana', label: 'Banana', icon: 'üçå' },
    { kind: 'item', id: 'Orange', label: 'Orange', icon: 'üçä' },
    { kind: 'item', id: 'Pineapple', label: 'Pineapple', icon: 'üçç' },
    { kind: 'item', id: 'Strawberry', label: 'Strawberry', icon: 'üçì' },
  ],
}

const FruitsMenu = () => {
  return (
    <ActionMenu
      trigger={<Button>Fruits</Button>}
      menu={menu}
    />
  )
}
```

## Nodes

Each node in the `MenuDef` describes what to render and how it should behave.

The library ships three kinds (`kind`) of nodes ‚Äî `item`, `group`, and `submenu`.

Their shapes are defined by the `ItemDef`, `GroupDef`, and `SubmenuDef` types.

### Item

```ts
{
  kind: 'item',
  id: 'done',
  label: 'Done',
  icon: <Status.Done />,
  onSelect: ({ node }) => {
    setStatus('done')
    toast(`Changed status to ${node.label}.`)
  }
  closeOnSelect: true
}
```

The atomic unit of the menu. It is a single row which performs an action when selected.

Each item must have a unique `id` among other sibling items. It does **not** have to be unique across submenus.

The action is defined by the `onSelect` handler, which gives you access to:

- The `node` instance, typed as `ItemNode<T>`.
- The `search` context, if the item is appearing in a filtered menu.

Optionally, you can specify an item `variant` to customize the look & functionality.

#### Button item

The default item variant is a `button`. You don't need to specify this, it is the default.

#### Checkbox item

```tsx {7,11,12}
const [checked, setChecked] = useState(false)

/* ... */

{
  kind: 'item',
  variant: 'checkbox',
  id: 'done',
  label: 'Done',
  icon: <Status.Done />,
  checked: checked,
  onCheckedChange: setChecked,
}
```

Adds a checkbox field to the item.

You must use this in a controlled manner by specifying `checked` and `onCheckedChange` props.

#### Radio item

```ts {3}
{
  kind: 'item',
  variant: 'radio',
  id: 'done',
  label: 'Done',
  icon: <Status.Done />,
}
```

To be used within a [radio group](#radio-group).

You can specify a `value` to be used. If omitted, the `id` will be used.

### Group

```ts
{
  kind: 'group',
  id: 'fruits',
  heading: 'Fruits', // optional!
  nodes: [
    { kind: 'item', id: 'apple',  label: 'Apple',  icon: 'üçé' },
    { kind: 'item', id: 'banana', label: 'Banana', icon: 'üçå' },
    { kind: 'item', id: 'orange', label: 'Orange', icon: 'üçä' },
  ],
}
```

Group items and submenus together with a optional `heading`.

You cannot nest groups.

#### Radio group

```tsx {7,9,10}
const [fruit, setFruit] = useState<string>('apple')

/* ... */

{
  kind: 'group',
  variant: 'radio',
  id: 'fruits',
  value: fruit,
  onValueChange: setFruit,
}
```

You can specify `variant: radio` for radio group functionality.

This requires the `value` and `onValueChange` props on the group.

### Submenu

```ts {2,10}
{
  kind: 'submenu',
  id: 'export-image',
  label: 'Image',
  title: 'Export Image',
  nodes: [
    { kind: 'item', id: 'export-png', label: 'PNG', icon: Image },
    { kind: 'item', id: 'export-jpg', label: 'JPG', icon: Image },
    {
      kind: 'submenu',
      id: 'export-vector',
      label: 'Vector',
      title: 'Vector',
      nodes: [
        { kind: 'item', id: 'export-svg', label: 'SVG', icon: Shapes },
        { kind: 'item', id: 'export-eps', label: 'EPS', icon: Ruler },
      ],
    },
  ],
}
```

A submenu of actions that the user can run.

The `label` property is used for the submenu's trigger.

You can specify the submenu content with the `nodes` property.

Submenus can be nested.

## Async loading

Submenus can load their content asynchronously using the `loader` prop. This is useful for lazy-loading menu data, fetching from APIs, or computing expensive menu structures on-demand.

### Basic async loading

The simplest way to use a loader is to provide an async function that returns an array of `NodeDef`:

```tsx
{
  kind: 'submenu',
  id: 'projects',
  label: 'Projects',
  loader: async ({ query, open }) => {
    const response = await fetch('/api/projects')
    const projects = await response.json()

    return projects.map(project => ({
      kind: 'item',
      id: project.id,
      label: project.name,
      icon: <Folder />,
      onSelect: () => navigateToProject(project.id)
    }))
  },
  nodes: [], // Optional: provide static fallback nodes
}
```

The loader function receives a context object with:
- `query` - The current search query (empty string if no search)
- `open` - Whether the submenu is currently open

### Loading and error states

Use the `Loading` and `Error` slots to customize what's shown during loading and error states:

```tsx
<ActionMenu
  trigger={<Button>Open menu</Button>}
  menu={menu}
  slots={{
    Loading: () => (
      <div className="flex items-center justify-center py-8">
        <Spinner className="size-4" />
        <span className="ml-2 text-sm text-muted-foreground">
          Loading...
        </span>
      </div>
    ),
    Error: ({ error }) => (
      <div className="px-4 py-8 text-center">
        <AlertCircle className="mx-auto size-8 text-destructive" />
        <p className="mt-2 text-sm font-medium">Failed to load</p>
        <p className="mt-1 text-xs text-muted-foreground">
          {error?.message}
        </p>
      </div>
    ),
  }}
/>
```

The `Error` slot receives:
- `error` - The error object that was thrown
- `menu` - The current menu definition

### Static loader results

You can also provide static loader results directly. This is useful when you already have the data but want to use the same loader API:

```tsx
{
  kind: 'submenu',
  id: 'projects',
  label: 'Projects',
  loader: {
    data: [
      { kind: 'item', id: 'p1', label: 'Project 1' },
      { kind: 'item', id: 'p2', label: 'Project 2' },
    ],
    isLoading: false,
    error: null,
    isError: false,
    isFetching: false,
  },
}
```

### React Query integration

For advanced use cases like caching, refetching, and optimistic updates, integrate with React Query using the `ReactQueryLoaderAdapter`:

```tsx
import { ActionMenu } from '@/components/ui/action-menu'
import { ReactQueryLoaderAdapter, createLoader } from '@bazza-ui/action-menu/integrations/react-query'

const menu: MenuDef = {
  id: 'root',
  nodes: [
    {
      kind: 'submenu',
      id: 'projects',
      label: 'Projects',
      loader: createLoader((context) => ({
        queryKey: ['projects', context.query],
        queryFn: async () => {
          const response = await fetch(
            `/api/projects?q=${context.query}`
          )
          return response.json()
        },
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 10 * 60 * 1000,   // 10 minutes
      })),
    },
  ],
}

function MyComponent() {
  return (
    <ActionMenu
      trigger={<Button>Projects</Button>}
      menu={menu}
      loaderAdapter={ReactQueryLoaderAdapter}
    />
  )
}
```

The `createLoader()` helper provides full TypeScript support for React Query options, including autocomplete and type checking.

**Why use React Query?**
- **Caching**: Query results are cached and shared across components
- **Background refetching**: Keep data fresh with automatic refetching
- **Deduplication**: Multiple identical requests are automatically deduplicated
- **Stale-while-revalidate**: Show cached data while fetching fresh data
- **Full React Query features**: Access to all React Query configuration options

**Without React Query:**
- Simpler API with zero dependencies
- Every loader call fetches fresh data
- No caching or request deduplication
- Perfect for simple use cases

### Deep search

By default, submenus with loaders have deep search enabled, making their descendants searchable from parent menus:

```tsx
{
  kind: 'submenu',
  id: 'settings',
  label: 'Settings',
  // deepSearch defaults to true - no need to specify it
  loader: async () => {
    return [
      {
        kind: 'submenu',
        id: 'appearance',
        label: 'Appearance',
        nodes: [
          { kind: 'item', id: 'theme', label: 'Theme' },
          { kind: 'item', id: 'font-size', label: 'Font Size' },
        ],
      },
      {
        kind: 'submenu',
        id: 'privacy',
        label: 'Privacy',
        nodes: [
          { kind: 'item', id: 'tracking', label: 'Tracking' },
          { kind: 'item', id: 'cookies', label: 'Cookies' },
        ],
      },
    ]
  },
}
```

With deep search enabled (the default):
- When the user searches "theme" from the root menu, it will find the "Theme" item nested inside Settings > Appearance
- Search results show breadcrumbs indicating the path: "Settings > Appearance > Theme"
- All descendant loaders are executed in parallel when searching
- Works with both native and React Query loaders

#### Disabling deep search

Set `deepSearch: false` to make a submenu's nodes only browsable/searchable from within that submenu:

```tsx
{
  kind: 'submenu',
  id: 'admin',
  label: 'Admin Panel',
  deepSearch: false, // Exclude from ancestor menu searches
  loader: async () => {
    return [
      { kind: 'item', id: 'users', label: 'Manage Users' },
      { kind: 'item', id: 'settings', label: 'System Settings' },
    ]
  },
}
```

When `deepSearch: false`:
- The submenu's items won't appear when searching from parent menus
- Descendant submenus are also excluded from deep search
- Users must navigate into the submenu to search its contents

**Performance note:** Deep search loads all descendant submenus simultaneously. Use React Query for caching to avoid redundant API calls when the user navigates back and forth.

## Rendering

Once you have your menu data, the next step is to render it.

### Concepts

The action menu's rendering system is built on three core concepts that work together to give you complete control over appearance and behavior.

Those are **slots**, **slot props**, and **classnames**.

#### Slots

Slots are render functions that define what gets rendered for each part of the menu. Think of them as customizable "components" for different menu elements.

Available slots:

- `Content` - Wraps the entire menu content
- `Header` - Optional header above the search input
- `Input` - The search/filter input field
- `List` - The scrollable list container
- `Empty` - Shown when search returns no results
- `Item` - Individual menu items (with variants for checkbox, radio, etc.)
- `SubmenuTrigger` - Items that open submenus
- `GroupHeading` - Headings for groups
- `Footer` - Optional footer below the list

Each slot receives props specific to what it renders. For example:
- `Item` receives `{ node, bind, search, mode }`
- `GroupHeading` receives `{ node, childCount, bind }`
- `Header` receives `{ menu }`

The `bind` object provides methods for getting properly configured props (with ARIA attributes, data attributes, refs, etc.) that should be spread onto your elements.

#### Slot props

Slot props are forwarded to the underlying elements. Use these to customize behavior without replacing the entire slot.

For instance, you might want to add ARIA attributes, event handlers, or other HTML props to the input or list elements:

```tsx
slotProps: {
  input: {
    'aria-label': 'Search menu items',
    autoComplete: 'off',
  },
  positioner: {
    sideOffset: 8,
    alignToFirstItem: true,
  }
}
```

#### Classnames

Classnames let you style individual parts of the menu using utility classes. Each part of the menu has a corresponding `className` key:

```tsx
classNames: {
  // Shell (wrapper/container)
  root: 'custom-root',
  trigger: 'custom-trigger',

  // Drawer (mobile)
  drawerOverlay: 'custom-drawer-overlay',
  drawerContent: 'custom-drawer-content',
  drawerContentInner: 'custom-drawer-inner',
  drawerHandle: 'custom-drawer-handle',

  // Surface (menu content)
  content: 'bg-popover rounded-lg',
  input: 'px-4 py-2 border-b',
  list: 'py-1 overflow-y-auto',

  // Items and groups
  item: 'px-4 py-2',
  subtrigger: 'px-4 py-2',
  group: 'mt-3',
  groupHeading: 'text-xs font-medium',
}
```

### Data attributes

Data attributes are available on slots, which can be used for powerful conditional styling.

#### Item

| Attribute | Values | Description |
|-----------|--------|-------------|
| `[data-focused]` | `true` | Item has keyboard/pointer focus |
| `[data-mode]` | `dropdown`, `drawer` | Display mode (desktop/mobile) |
| `[data-variant]` | `button`, `checkbox`, `radio` | Item type |
| `[data-checked]` | `true`, `false` | Checkbox/radio checked state |
| `[data-group-position]` | `first`, `middle`, `last`, `only` | Position within group (if in a group) |
| `[data-group-index]` | `number` | Zero-based index within group (if in a group) |
| `[data-group-size]` | `number` | Total number of items in group (if in a group) |
| `[data-index]` | `number` | Virtual index in the list |
| `[data-action-menu-item-id]` | `string` | Unique item identifier |
| `[aria-disabled]` | `true`, `false` | Item is disabled |
| `[aria-selected]` | `true`, `false` | Item is selected/focused |
| `[disabled]` | `true`, `false` | Native disabled attribute |

#### Submenu trigger

| Attribute | Values | Description |
|-----------|--------|-------------|
| `[data-focused]` | `true`, `false` | Trigger has keyboard/pointer focus |
| `[data-mode]` | `dropdown`, `drawer` | Display mode (desktop/mobile) |
| `[data-menu-state]` | `open`, `closed` | Submenu open/closed state |
| `[data-menu-focused]` | `true`, `false` | Submenu itself has focus |
| `[data-subtrigger]` | `true` | Identifies element as submenu trigger |
| `[data-group-position]` | `first`, `middle`, `last`, `only` | Position within group (if in a group) |
| `[data-group-index]` | `number` | Zero-based index within group (if in a group) |
| `[data-group-size]` | `number` | Total number of items in group (if in a group) |
| `[data-index]` | `number` | Virtual index in the list |
| `[data-action-menu-item-id]` | `string` | Unique trigger identifier |
| `[aria-selected]` | `true`, `false` | Trigger is selected/focused |
| `[aria-disabled]` | `true`, `false` | Trigger is disabled |

#### Content

| Attribute | Values | Description |
|-----------|--------|-------------|
| `[data-state]` | `open`, `closed` | Menu state |
| `[data-mode]` | `dropdown`, `drawer` | Display mode (desktop/mobile) |
| `[data-root-menu]` | `true` | Is the root menu |
| `[data-sub-menu]` | `true` | Is a submenu |
| `[data-side]` | `top`, `right`, `bottom`, `left` | Popper positioning side |
| `[data-action-menu-surface]` | `true` | Identifies element as menu surface |
| `[data-surface-id]` | `string` | Unique surface identifier |
| `[data-slot]` | `action-menu-content` | Slot identifier |

#### Input

| Attribute | Values | Description |
|-----------|--------|-------------|
| `[data-mode]` | `dropdown`, `drawer` | Display mode (desktop/mobile) |
| `[data-slot]` | `action-menu-input` | Slot identifier |
| `[data-action-menu-input]` | `true` | Identifies element as menu input |

#### List

| Attribute | Values | Description |
|-----------|--------|-------------|
| `[data-slot]` | `action-menu-list` | Slot identifier |
| `[data-action-menu-list]` | `true` | Identifies element as menu list |

#### GroupHeading

The `GroupHeading` slot renders the heading content for a group. Use `bind.getGroupHeadingProps()` to get configured props.

| Attribute | Values | Description |
|-----------|--------|-------------|
| `[data-group-size]` | `number` | Total number of items in the group |

#### Drawer overlay

| Attribute | Values | Description |
|-----------|--------|-------------|
| `[data-state]` | `open`, `closed` | Drawer state |
| `[data-slot]` | `action-menu-overlay` | Slot identifier |

#### Drawer content

| Attribute | Values | Description |
|-----------|--------|-------------|
| `[data-vaul-drawer-direction]` | `top`, `bottom` | Drawer slide direction |
| `[data-slot]` | `action-menu-drawer-content` | Slot identifier |

#### Examples

Style focused items:
```tsx
item: 'data-[focused=true]:bg-accent data-[focused=true]:text-accent-foreground'
```

Style by display mode:
```tsx
item: 'data-[mode=dropdown]:px-4 data-[mode=drawer]:px-6'
```

Style submenu triggers when open:
```tsx
subtrigger: 'data-[menu-state=open]:bg-accent'
```

Combine multiple conditions:
```tsx
item: 'data-[focused=true]:data-[variant=checkbox]:font-semibold'
```

Style group headings:
```tsx
groupHeading: 'text-xs font-medium uppercase tracking-wide text-muted-foreground'
```

Style items based on group position (visual grouping):
```tsx
// Rounded corners on first/last items in groups
item: 'data-[group-position=first]:rounded-t-md data-[group-position=last]:rounded-b-md data-[group-position=only]:rounded-md'
```

Add borders between grouped items:
```tsx
// Border on all but the last item
item: 'data-[group-position=first]:border-b data-[group-position=middle]:border-b'
```

### Theming

The library provides four layers of theming to customize the menu's appearance and behavior:

1. **Global theme:** create a reusable, styled action menu in your design system with `createActionMenu()`.
2. **Instance theme:** Override your styled action menu's defaults for each component instance.
3. **Surface theme:** Override per menu/submenu with the the `ui` prop on `MenuDef` and `SubmenuDef`.
4. Pass a custom `render()` function to each node definition.

When you install the component from the bazza/ui registry, we use the first mechanism, `createActionMenu()`, to create a styled action menu with sensible defaults.

While #1 may be enough in most cases, you may need additional customization on a per-instance basis. This is where #2 comes in.

#3 is used when you want to customize a specific menu or submenu within an action menu instance -- for example, to render all items in submenu `x` with a blue background.

Finally, #4 is used when you want to customize the rendering of a specific node within a menu or submenu.

#### Global theme

Create a reusable, styled action menu component for your design system using `createActionMenu()`:

```tsx
import { createActionMenu, defaultSlots, renderIcon } from '@bazza-ui/action-menu'

export const ActionMenu = createActionMenu({
  slots: {
    Item: ({ node, bind, search }) => {
      const props = bind.getRowProps({
        className: 'group/row',
      })

      return (
        <li {...props}>
          {node.icon && (
            <div className="size-4">
              {renderIcon(node.icon, 'size-4 text-muted-foreground')}
            </div>
          )}
          <span>{node.label}</span>
        </li>
      )
    },
    Empty: ({ query }) =>
      query ? <div>No results found.</div> : null,
  },
  slotProps: {
    positioner: {
      sideOffset: 4,
    },
  },
  classNames: {
    content: 'bg-popover border rounded-lg shadow-md',
    input: 'px-4 py-2 border-b',
    list: 'py-1 max-h-[300px] overflow-y-auto',
    item: 'px-4 py-2 cursor-pointer hover:bg-accent',
  },
})
```

This creates a styled `ActionMenu` component that you can use throughout your application:

```tsx
<ActionMenu
  trigger={<Button>Open menu</Button>}
  menu={{ id: 'root', nodes: [...] }}
/>
```

The `bind` object provides methods like `getRowProps()` and `getContentProps()` that handle all the necessary ARIA attributes, event handlers, and virtualization for you. Always spread these props onto your elements.

You can reference the default slots using `defaultSlots()` when you want to conditionally override behavior:

```tsx
slots: {
  List: (args) =>
    args.nodes.length === 0 ? null : defaultSlots().List(args),
}
```

#### Instance theme

Override your global theme for specific action menu instances by passing `slots`, `slotProps`, or `classNames` directly to the component:

```tsx
<ActionMenu
  trigger={<Button>Custom menu</Button>}
  menu={{ id: 'root', nodes: [...] }}
  slots={{
    Header: () => <div className="px-4 py-2 font-bold">Custom Header</div>,
  }}
  slotProps={{
    positioner: {
      side: 'right',
      sideOffset: 8,
    },
  }}
  classNames={{
    content: 'w-[500px]',
    item: 'text-lg',
  }}
/>
```

Instance-level customizations are merged with (and override) your global theme. This is useful when you need a one-off variation without creating a new themed component.

#### Surface theme

Customize individual menus or submenus using the `ui` prop on `MenuDef` or `SubmenuDef`:

```tsx
const menu: MenuDef = {
  id: 'root',
  nodes: [
    {
      kind: 'submenu',
      id: 'danger-zone',
      label: 'Danger Zone',
      ui: {
        classNames: {
          input: 'bg-red-950 border-red-800',
          item: 'data-[focused=true]:bg-red-950',
          content: 'border-red-800',
        },
      },
      nodes: [
        { kind: 'item', id: 'delete', label: 'Delete' },
        { kind: 'item', id: 'archive', label: 'Archive' },
      ],
    },
  ],
}
```

You can also use slots and slotProps at the surface level:

```tsx
const menu: MenuDef = {
  id: 'root',
  ui: {
    slots: {
      Header: ({ menu }) => (
        <div className="px-4 py-2 border-b">
          {menu.title}
        </div>
      ),
      Footer: () => (
        <div className="px-4 py-2 border-t text-xs text-muted-foreground">
          Press ? for help
        </div>
      ),
    },
  },
  nodes: [...],
}
```

Surface-level customizations only affect that specific menu/submenu and its descendants (unless overridden).

#### Using the `render()` function

For maximum control, use the `render()` function on individual node definitions:

```tsx
{
  kind: 'item',
  id: 'custom-item',
  label: 'Custom Item',
  render: ({ node, bind, mode, search }) => {
    const props = bind.getRowProps()

    return (
      <li {...props} className="flex items-center gap-2 px-4 py-2">
        <CustomIcon />
        <div>
          <div className="font-semibold">{node.label}</div>
          <div className="text-xs text-muted-foreground">
            Custom description
          </div>
        </div>
        {search && <Badge>Match</Badge>}
      </li>
    )
  }
}
```

The `render()` function receives:

- `node` - The node instance with all its properties
- `bind` - Binding API with methods like `getRowProps()`
- `mode` - Current responsive mode (`'dropdown'` or `'drawer'`)
- `search` - Search context if item is visible via search (includes `query`, `score`, `breadcrumbs`)

Always use `bind.getRowProps()` and spread the result onto your root element to ensure proper keyboard navigation, focus management, and accessibility.

Custom render functions completely replace the slot rendering for that specific node, giving you full control while maintaining the menu's core functionality.

## Examples

### Basic

<ComponentFrame
  containerClassName='sm:h-64'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/basic.tsx"
  lazy
>
  <Examples.ActionMenu.Basic />
</ComponentFrame>

### Disabled items

<ComponentFrame
  containerClassName='sm:h-64'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/disabled-items.tsx"
  lazy
>
  <Examples.ActionMenu.DisabledItems />
</ComponentFrame>

### Checkbox items

<ComponentFrame
  containerClassName='sm:h-64'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/checkbox-items.tsx"
  lazy
>
  <Examples.ActionMenu.CheckboxItems />
</ComponentFrame>

### Groups

<ComponentFrame
  containerClassName='sm:h-64'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/groups.tsx"
  lazy
>
  <Examples.ActionMenu.Groups />
</ComponentFrame>

### Radio groups

<ComponentFrame
  containerClassName='sm:h-64'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/radio-groups.tsx"
  lazy
>
  <Examples.ActionMenu.RadioGroups />
</ComponentFrame>

### Submenus

<ComponentFrame
  containerClassName='sm:h-84'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/submenus.tsx"
  lazy
>
  <Examples.ActionMenu.Submenus />
</ComponentFrame>

### Nested submenus

<ComponentFrame
  containerClassName='sm:h-124'
  src="components/examples/action-menu/submenus-deep.tsx"
  lazy
>
  <Examples.ActionMenu.SubmenusDeep />
</ComponentFrame>

### Customized submenus

<ComponentFrame
  containerClassName='sm:h-104'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/submenus-customized.tsx"
  lazy
>
  <Examples.ActionMenu.SubmenusCustomized />
</ComponentFrame>

### Item descriptions

<ComponentFrame
  containerClassName='sm:h-84'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/item-descriptions.tsx"
  lazy
>
  <Examples.ActionMenu.ItemDescriptions />
</ComponentFrame>

### Header + footer

<ComponentFrame
  containerClassName='sm:h-104'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/header-footer.tsx"
  lazy
>
  <Examples.ActionMenu.HeaderFooter />
</ComponentFrame>

### Massive (10,000 items)

<ComponentFrame
  containerClassName='sm:h-64'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/massive.tsx"
  lazy
>
  <Examples.ActionMenu.Massive numItems={10_000} />
</ComponentFrame>

### Notion

<ComponentFrame
  containerClassName='sm:h-116'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/notion.tsx"
  lazy
>
  <Examples.ActionMenu.Notion />
</ComponentFrame>

### Linear

<ComponentFrame
  className='mb-16'
  containerClassName='h-104'
  src="components/examples/action-menu/linear.tsx"
  lazy
>
  <Examples.ActionMenu.Linear />
</ComponentFrame>

### Linear (async)

<ComponentFrame
  className='mb-16'
  containerClassName='h-104'
  src="components/examples/action-menu/linear-async.tsx"
  lazy
>
  <Examples.ActionMenu.LinearAsync />
</ComponentFrame>

### AI model switcher

<ComponentFrame
  containerClassName='sm:h-84'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/ai-model-switcher.tsx"
  lazy
>
  <Examples.ActionMenu.AIModelSwitcher />
</ComponentFrame>

### Async basic

<ComponentFrame
  containerClassName='sm:h-84'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/async-basic.tsx"
  lazy
>
  <Examples.ActionMenu.AsyncBasic />
</ComponentFrame>

### Async submenus

<ComponentFrame
  containerClassName='sm:h-104'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/async-submenus.tsx"
  lazy
>
  <Examples.ActionMenu.AsyncSubmenus />
</ComponentFrame>

### Async deep search

<ComponentFrame
  containerClassName='sm:h-104'
  previewClassName='w-full flex justify-center'
  src="components/examples/action-menu/async-deep-search.tsx"
  lazy
>
  <Examples.ActionMenu.AsyncDeepSearch />
</ComponentFrame>

## API reference

### MenuNodeKind

```ts
type MenuNodeKind = 'item' | 'group' | 'submenu'
```

### Node

```ts
type Node<T = unknown> = ItemNode<T> | GroupNode<T> | SubmenuNode<T, any>
```

### NodeDef

```ts
type NodeDef<T = unknown> = ItemDef<T> | GroupDef<T> | SubmenuDef<T, any>
```

### Iconish

```ts
type Iconish =
  | React.ReactNode
  | React.ReactElement
  | React.ElementType
  | React.ComponentType<{ className?: string }>
```
