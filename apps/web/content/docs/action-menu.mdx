---
title: Action menu
section: Components
summary: A composable menu with deep search and multi-level submenus.
badge: alpha
---

<ComponentFrame 
  className='mb-16' 
  containerClassName='h-104' 
  caption={<>A subset of <a href="https://linear.app/homepage">Linear</a>'s filter menu, recreated with the bazza/ui action menu.</>}
>
  <Examples.ActionMenu.KitchenSink01 />
</ComponentFrame>

The action menu is a primitive component for building menu interfaces.

At its core, it combines the best features of the dropdown and command menus available today, while adding deep search capabilities.

## Features

- Data-first API with headless, slot-based rendering.
- Supports submenus with [intent zones](https://linear.app/now/invisible-details) for easy, fluid pointer navigation.
- Deep search across submenus; descendants are searchable from ancestors.
- Fully typed with generics for your own menu data, customizable per submenu.
- Full keyboard navigation with vim-style keybindings built-in.
- Responsive design; renders a dropdown on desktop and a [drawer](https://vaul.emilkowal.ski) on mobile.
- Supports modal and non-modal modes.
- Customize side, alignment, offsets, collision handling.
- Focus is fully managed; follows the `aria-activedescendant` pattern.

## Installation

Install the unstyled, primitive component as an npm package:

```bash
npm install @bazza-ui/action-menu
```

Want something styled with sensible defaults? Install from our registry with one command.

- Installs the `@bazza-ui/action-menu` package
- Creates the `@/components/ui/action-menu.tsx` file with a styled `ActionMenu` component

```bash
npx shadcn@latest add https://ui.bazza.dev/r/action-menu
```

## Anatomy

```tsx
<ActionMenu.Root>
  <ActionMenu.Trigger />
  <ActionMenu.Positioner>
    <ActionMenu.Surface menu={menu} />
  </ActionMenu.Positioner>
</ActionMenu.Root>
```

### Root

Provides the shell (dropdown or drawer), the open/close state, and cross-surface focus ownership.

You can control visibility with `defaultOpen` for uncontrolled state, or `open` and `onOpenChange` for controlled state.

You can determine whether pointer events outside the menu are blocked by setting `modal` (defaults to `true`).

### Trigger

A button that toggles the menu.

In dropdown mode, it acts as the `Popper` anchor, and in drawer mode it renders as a Vaul `Drawer.Trigger`.

### Positioner

Positions a surface in dropdown mode and is used automatically for submenus.

It is a no-op for the root surface in drawer mode.

### Surface

Contains the search input, menu groups and rows, as well as an optional header and footer. 

You render one surface for the root menu. Submenus automatically render their own surfaces.

## Data

This component uses a data-first API. You define your menu as a `MenuDef` object and pass it to the root `ActionMenu.Surface` component:

```tsx {17}
const menu: MenuDef = {
  nodes: [
    { kind: 'item', id: 'Apple', label: 'Apple', icon: 'ðŸŽ' },
    { kind: 'item', id: 'Banana', label: 'Banana', icon: 'ðŸŒ' },
    { kind: 'item', id: 'Orange', label: 'Orange', icon: 'ðŸŠ' },
    { kind: 'item', id: 'Pineapple', label: 'Pineapple', icon: 'ðŸ' },
    { kind: 'item', id: 'Strawberry', label: 'Strawberry', icon: 'ðŸ“' },
  ],
}

const FruitsMenu = () => {
  return (
    <ActionMenu.Root>
      <ActionMenu.Trigger>Open</ActionMenu.Trigger>
      <ActionMenu.Positioner>
        <ActionMenu.Surface menu={menu} />
      </ActionMenu.Positioner>
    </ActionMenu.Root>
  )
}
```

## Nodes

Each node in the `MenuDef` describes what to render and how it should behave.

The library ships three kinds of nodes â€” item, group, and submenu.

Their shapes are defined by the `ItemDef`, `GroupDef`, and `SubmenuDef` types.

### Item

```ts
{
  kind: 'item',
  id: 'done',
  label: 'Done',
  icon: <Status.Done />,
  onSelect: ({ node, search }) => {
    setStatus('done')
    toast(`Changed status to ${node.label}.`)
  }
  closeOnSelect: true
}
```

The atomic unit of the menu. It is a single row which performs an action when selected.

Each item must have a unique `id` among other sibling items. It does **not** have to be unique across submenus.

The action is defined by the `onSelect` handler, which gives you access to:

- The `node` instance, typed as `ItemNode<T>`.
- The `search` context, if the item is appearing in a filtered menu.

#### API reference

##### ItemDef

<TypeTable pkg="@bazza-ui/action-menu" type="ItemDef" />

##### ItemNode

<TypeTable pkg="@bazza-ui/action-menu" type="ItemNode" />

### Group

Groups items and submenus together with a `heading`.

##### API reference

<TypeTable pkg="@bazza-ui/action-menu" type="GroupDef" />

### Submenu

A submenu of actions that the user can run.

##### API reference

<TypeTable pkg="@bazza-ui/action-menu" type="SubmenuDef" />

## Factory

_In progress._

## Examples

### Basic

<ComponentFrame
  containerClassName='sm:h-64' 
  previewClassName='w-full flex justify-center' 
  src="components/examples/action-menu/basic.tsx"
>
  <Examples.ActionMenu.Basic />
</ComponentFrame>

### Submenus

<ComponentFrame 
  containerClassName='sm:h-84' 
  previewClassName='w-full flex justify-center'   
  src="components/examples/action-menu/submenus.tsx"
>
  <Examples.ActionMenu.Submenus />
</ComponentFrame>

### Nested submenus

<ComponentFrame 
  containerClassName='sm:h-124' 
  src="components/examples/action-menu/submenus-deep.tsx"
>
  <Examples.ActionMenu.SubmenusDeep />
</ComponentFrame>

### Header + footer

<ComponentFrame 
  containerClassName='sm:h-104' 
  previewClassName='w-full flex justify-center'   
  src="components/examples/action-menu/header-footer.tsx"
>
  <Examples.ActionMenu.HeaderFooter />
</ComponentFrame>
